{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Debug Adapter Client for Python","text":"<p>DAP Client is an up-to-date generic client side implementation of the Debug Adapter Protocol (DAP) that is used in IDEs, editors and other tools to communicate with different debuggers. The client is not tied to any specific debugger, so it can be used to interact with any debug adapter that implements the DAP protocol, significantly reducing the effort required to build a new debugging tool.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Sans I/O Implementation: A protocol-only client that can be integrated into any I/O framework.</li> <li>Abstract Clients: Ready-to-use threaded and asyncio clients for immediate integration.</li> <li>Flexible Architecture: Easily extensible to support various debugging scenarios.</li> </ul>"},{"location":"#table-of-contents","title":"Table of Contents","text":"<ol> <li>Installation</li> <li>Quick Start</li> <li>Usage Examples</li> <li>API Reference</li> <li>License</li> </ol>"},{"location":"#installation","title":"Installation","text":"<p>Install DAP Client using pip:</p> <pre><code>pip install dap-client\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<p>The following example demonstrates how to use the async client to connect to a <code>debugpy</code> debug adapter server that is running on port 1234.</p> <pre><code>python -m debugpy --listen localhost:1234 --wait-for-client hello.py\n</code></pre> <pre><code>import asyncio\nfrom dap import AsyncServer\n\nasync def main():\n    server = AsyncServer(\"debugpy\", port=1234)\n    try:\n        await server.start()\n    except asyncio.CancelledError:\n        await server.stop()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"#usage-examples","title":"Usage Examples","text":""},{"location":"#using-the-sans-io-client","title":"Using the Sans I/O Client","text":"<p>The sans I/O client allows you to implement your own I/O mechanism:</p> <pre><code>from dap import Client\nfrom dap.responses import Initialized\n\nclient = Client()\nclient.launch(no_debug=True)\n\n# get the request data\nrequest = client.send()\n\n# send the request using your I/O implementation\n# ...\n\n# feed the response data to the client\nfor result in client.receive(response_data):\n    if isinstance(result, Initialized):\n        print(\"The debug adapter is initialized.\")\n    ...\n</code></pre>"},{"location":"#using-the-threaded-socket-io-client","title":"Using the Threaded Socket IO Client","text":"<p>The threaded client provides a simple interface for synchronous usage:</p> <pre><code>from dap import ThreadedServer\n\nserver = ThreadedServer(\"debugpy\", port=1234)\nserver.start()\nclient = server.client\n\n# Use the client synchronously\nclient.launch()\nclient.disconnect()\nserver.stop()\n</code></pre>"},{"location":"#using-the-asyncio-client","title":"Using the Asyncio Client","text":"<p>The asyncio client offers an asynchronous interface:</p> <pre><code>import asyncio\nfrom dap import AsyncServer\n\nasync def debug_session():\n    server = AsyncServer(\"debugpy\", port=1234)\n    server.start()\n    client = server.client\n\n    client.launch()\n    client.disconnect()\n    server.stop()\n\nasyncio.run(debug_session())\n</code></pre>"},{"location":"#license","title":"License","text":"<p>DAP Client is released under the MIT License.</p>"},{"location":"api-reference/","title":"API Reference","text":""},{"location":"api-reference/#sans-io-client","title":"Sans-IO Client","text":"<p>Debug Adapter Protocol (DAP) Client implementation without connection handling.</p> <p>The client is responsible for sending requests and receiving events from the debug adapter. It is up to the user to handle the connection to the debug adapter, making it more flexible.</p> <p>The client can be used in a synchronous or asynchronous manner, depending on the user's needs.</p> Source code in <code>src\\dap\\client.py</code> <pre><code>class Client:\n    \"\"\"Debug Adapter Protocol (DAP) Client implementation without connection handling.\n\n    The client is responsible for sending requests and receiving events from the debug adapter.\n    It is up to the user to handle the connection to the debug adapter, making it more flexible.\n\n    The client can be used in a synchronous or asynchronous manner, depending on the user's needs.\n    \"\"\"\n\n    def __init__(\n        self,\n        adapter_id: str,\n        client_id: Optional[str] = None,\n        client_name: Optional[str] = None,\n        locale: Optional[str] = None,\n        lines_start_at1: Optional[bool] = None,\n        columns_start_at1: Optional[bool] = None,\n        path_format: Optional[Literal[\"path\", \"uri\"] | str] = None,\n    ) -&gt; None:\n        \"\"\"Initializes the debug adapter client.\n\n        Args:\n            adapter_id: The ID of the debug adapter.\n            client_id: The ID of the client.\n            client_name: The name of the client.\n            locale: The locale of the client.\n            lines_start_at1: Whether the lines start at 1.\n            columns_start_at1: Whether the columns start at 1.\n            path_format: The format of the paths.\n        \"\"\"\n\n        self._seq: int = 1\n        self._send_buf = bytearray()\n        self._receive_buf = bytearray()\n        self._pending_requests: dict[int, Request] = {}\n\n        self.handler = Handler(self)\n\n        self.initialize(\n            adapter_id=adapter_id,\n            client_id=client_id,\n            client_name=client_name,\n            locale=locale,\n            lines_start_at1=lines_start_at1,\n            columns_start_at1=columns_start_at1,\n            path_format=path_format,\n            supports_variable_type=True,\n            supports_variable_paging=True,\n            supports_run_in_terminal_request=True,\n            supports_memory_references=True,\n            supports_progress_reporting=True,\n            supports_invalidated_event=True,\n            supports_memory_event=True,\n            supports_args_can_be_interpreted_by_shell=True,\n            supports_start_debugging_request=True,\n        )\n\n    def send_request(\n        self, command: str, arguments: Optional[dict[str, Any]] = None\n    ) -&gt; int:\n        \"\"\"Send a request to the debug adapter.\n\n        This can be useful for sending requests that are not yet implemented in the client or\n        for sending custom requests to the debug adapter that are specific to the adapter.\n\n        Args:\n            command: The command to send.\n            arguments: The arguments to send.\n\n        Returns:\n            The sequence number of the request.\n        \"\"\"\n\n        seq = self._seq\n        self._seq += 1\n\n        self._send_buf += RequestBuffer(seq, command, arguments)\n        self._pending_requests[seq] = Request(\n            seq=seq, command=command, arguments=arguments\n        )\n        return seq\n\n    def receive(self, data: bytes) -&gt; Generator[ResponseBody | EventBody, None, None]:\n        \"\"\"Feed data from the debug adapter to the client.\n\n        Args:\n            data: The data to receive.\n\n        Yields:\n            The response or event body.\n        \"\"\"\n\n        self._receive_buf += data\n        yield from self.handler.handle()\n\n    def send(self) -&gt; bytes:\n        \"\"\"Get the data to send to the debug adapter.\n\n        Returns:\n            The data to send.\n        \"\"\"\n\n        send_buf = self._send_buf\n        self._send_buf = bytearray()\n        return send_buf\n\n    # Requests\n    def cancel(\n        self, request_id: Optional[int] = None, progress_id: Optional[str] = None\n    ) -&gt; int:\n        \"\"\"The cancel request is used by the client in two situations:\n\n        - to indicate that it is no longer interested in the result produced by a specific request issued earlier\n        - to cancel a progress sequence.\n\n        Both `progress_id` and `request_id` CAN BE specified in the same request.\n\n        Args:\n            request_id: The ID (_seq) of the request to cancel. If missing no request is canceled.\n            progress_id: The progress ID of the progress sequence to cancel. If missing no progress is canceled.\n        \"\"\"\n\n        return self.send_request(\n            \"cancel\", {\"requestId\": request_id, \"progressId\": progress_id}\n        )\n\n    def attach(self, __restart: Optional[Any] = None) -&gt; int:\n        \"\"\"attach to a running process.\n\n        Args:\n            __restart: Arbitrary data from the previous, restarted session. \\\n                The data is sent as the `restart` attribute of the `terminated` event.\"\"\"\n\n        return self.send_request(\"attach\", {\"__restart\": __restart})\n\n    def breakpoint_locations(\n        self,\n        source: Source,\n        line: int,\n        column: Optional[int] = None,\n        end_line: Optional[int] = None,\n        end_column: Optional[int] = None,\n    ) -&gt; int:\n        \"\"\"Retrieve all possible locations for source breakpoints in a given range.\n\n        Args:\n            source: The source location of the breakpoints.\n            line: The source line of the breakpoints.\n            column: An optional source column of the breakpoints.\n            end_line: An optional end line of the range covered by the breakpoint.\n            end_column: An optional end column of the range covered by the breakpoint.\n        \"\"\"\n\n        return self.send_request(\n            \"breakpointLocations\",\n            {\n                \"source\": source,\n                \"line\": line,\n                \"column\": column,\n                \"endLine\": end_line,\n                \"endColumn\": end_column,\n            },\n        )\n\n    def completions(\n        self,\n        text: str,\n        column: int,\n        line: Optional[int],\n        frame_id: Optional[int] = None,\n    ) -&gt; int:\n        \"\"\"Returns a list of possible completions for a given caret position and text.\n\n        Args:\n            text: One or more source lines. Typically this is the text users have typed into \\\n                the debug console before they asked for completion.\n            column: The position within `text` for which to determine the completion proposals.\n            line: A line for which to determine the completion proposals. If missing the \\\n                first line of the text is assumed.\n            frame_id: An optional frameId of the stack frame, if specified returns \\\n                completions in the scope of this stack frame.\n        \"\"\"\n\n        return self.send_request(\n            \"completions\",\n            {\n                \"frameId\": frame_id,\n                \"text\": text,\n                \"column\": column,\n                \"line\": line,\n            },\n        )\n\n    def configuration_done(self) -&gt; int:\n        \"\"\"This request indicates that the client has finished initialization of the debug adapter.\"\"\"\n\n        return self.send_request(\"configurationDone\")\n\n    def continue_(self, thread_id: int, single_thread: Optional[bool] = None) -&gt; int:\n        \"\"\"The request resumes execution of all threads.\n        If the debug adapter supports single thread execution, setting `single_thread` true resumes only the specified thread.\n\n        Args:\n            thread_id: the active thread.\n            single_thread: Execute only this thread.\n        \"\"\"\n\n        return self.send_request(\n            \"continue\", {\"threadId\": thread_id, \"singleThread\": single_thread}\n        )\n\n    def data_breakpoint_info(\n        self,\n        name: str,\n        variables_reference: Optional[int] = None,\n        frameId: Optional[int] = None,\n        bytes: Optional[int] = None,\n        asAddress: Optional[bool] = None,\n        mode: Optional[str] = None,\n    ) -&gt; int:\n        \"\"\"Retrieve the information of a data breakpoint.\n\n        Args:\n            variables_reference: Reference to the variable container if the data breakpoint is requested for \\\n                a child of the container.\n            name: The name of the variable's child to obtain data breakpoint information for.\n            frameId: When `name` is an expression, evaluate it in the scope of this stack frame.\n            bytes: If specified, a debug adapter should return information for the range of memory extending \\\n                `bytes` number of bytes from the address or variable specified by `name`. \\\n                Breakpoints set using the resulting data ID should pause on data access anywhere within that range.\n            asAddress: If true, `name` is an address.\n            mode: The mode of the desired breakpoint.\n        \"\"\"\n\n        return self.send_request(\n            \"dataBreakpointInfo\",\n            {\n                \"variablesReference\": variables_reference,\n                \"name\": name,\n                \"frameId\": frameId,\n                \"bytes\": bytes,\n                \"asAddress\": asAddress,\n                \"mode\": mode,\n            },\n        )\n\n    def disassemble(\n        self,\n        memory_reference: str,\n        instruction_count: Optional[int] = None,\n        offset: Optional[int] = None,\n        instruction_offset: Optional[int] = None,\n        resolve_symbols: Optional[bool] = None,\n    ) -&gt; int:\n        \"\"\"Disassembles code stored at the provided location.\n\n        Args:\n            memory_reference: Memory reference to the base location containing the instructions to disassemble.\n            instruction_count: The number of instructions to disassemble starting at the specified location and offset.\n            offset: The offset (in bytes) of the first instruction to disassemble.\n            instruction_offset: The offset (in instructions) of the first instruction to disassemble.\n            resolve_symbols: If set to true, the adapter should attempt to resolve memory addresses \\\n                to function names and line numbers.\n        \"\"\"\n\n        return self.send_request(\n            \"disassemble\",\n            {\n                \"memoryReference\": memory_reference,\n                \"offset\": offset,\n                \"instructionCount\": instruction_count,\n            },\n        )\n\n    def disconnect(\n        self,\n        restart: Optional[bool] = None,\n        terminal_debuggee: Optional[bool] = None,\n        suspend_debuggee: Optional[bool] = None,\n    ) -&gt; int:\n        \"\"\"Asks the debug adapter to disconnect from the debuggee (thus ending the debug session) and then to shut down.\n\n        In addition, the debug adapter must terminate the debuggee if it was started with the launch request.\n        If an attach request was used to connect to the debuggee, then the debug adapter must not terminate the debuggee.\n\n        Args:\n            restart: A value of true indicates that this 'disconnect' request is part of a restart sequence.\n            terminal_debuggee: Indicates whether the debuggee should be terminated when the debugger is disconnected.\n            suspend_debuggee: Indicates whether the debuggee should be allowed to run after the debugger is disconnected.\n        \"\"\"\n\n        return self.send_request(\n            \"disconnect\",\n            {\n                \"restart\": restart,\n                \"terminateDebuggee\": terminal_debuggee,\n                \"suspendDebuggee\": suspend_debuggee,\n            },\n        )\n\n    def evaluate(\n        self,\n        expression: str,\n        frame_id: Optional[int] = None,\n        line: Optional[int] = None,\n        column: Optional[int] = None,\n        source: Optional[Source] = None,\n        context: Optional[\n            Literal[\"watch\", \"repl\", \"hover\", \"clipboard\", \"variables\"] | str\n        ] = None,\n        format: Optional[ValueFormat] = None,\n    ) -&gt; int:\n        \"\"\"Evaluate the given expression in the context of topmost stack frame.\n        The expression has access to any variables and arguments that are in scope.\n\n        Args:\n            expression: The expression to evaluate.\n            frame_id: Evaluate the expression in the scope of this stack frame. \\\n                If not specified, the expression is evaluated in the global scope.\n            line: The contextual line where the expression should be evaluated. \\\n                In the 'hover' context, this should be set to the start of the expression being hovered.\n            column: The contextual column where the expression should be evaluated. \\\n                This may be provided if `line` is also provided.\n            source: The contextual source in which the `line` is found. \\\n                This must be provided if `line` is provided.\n            context: The context in which the evaluate request is used.\n            format: Specifies details on how to format the result.\n        \"\"\"\n\n        return self.send_request(\n            \"evaluate\",\n            {\n                \"expression\": expression,\n                \"frameId\": frame_id,\n                \"line\": line,\n                \"column\": column,\n                \"source\": source,\n                \"context\": context,\n                \"format\": format,\n            },\n        )\n\n    def exception_info(self, thread_id: int) -&gt; int:\n        \"\"\"Retrieves the details of the exception that caused this event to be raised.\n\n        Args:\n            thread_id: Thread for which exception information should be retrieved.\n        \"\"\"\n\n        return self.send_request(\"exceptionInfo\", {\"threadId\": thread_id})\n\n    def goto(self, thread_id: int, target_id: str) -&gt; int:\n        \"\"\"The request sets the location where the debuggee will continue to run.\n\n        Args:\n            thread_id: The thread to continue.\n            target_id: The location where the debuggee will continue to run.\n        \"\"\"\n\n        return self.send_request(\"goto\", {\"threadId\": thread_id, \"targetId\": target_id})\n\n    def goto_targets(\n        self, source: Source, line: int, column: Optional[int] = None\n    ) -&gt; int:\n        \"\"\"Retrieve possible goto targets for the specified location.\n\n        Args:\n            source: The source location for which the goto targets are determined.\n            line: The line for which the goto targets are determined.\n            column: An optional column for which the goto targets are determined.\n        \"\"\"\n\n        return self.send_request(\n            \"gotoTargets\", {\"source\": source, \"line\": line, \"column\": column}\n        )\n\n    def initialize(\n        self,\n        adapter_id: str,\n        client_id: Optional[str] = None,\n        client_name: Optional[str] = None,\n        locale: Optional[str] = None,\n        lines_start_at1: Optional[bool] = None,\n        columns_start_at1: Optional[bool] = None,\n        path_format: Optional[Literal[\"path\", \"uri\"] | str] = None,\n        supports_variable_type: Optional[bool] = None,\n        supports_variable_paging: Optional[bool] = None,\n        supports_run_in_terminal_request: Optional[bool] = None,\n        supports_memory_references: Optional[bool] = None,\n        supports_progress_reporting: Optional[bool] = None,\n        supports_invalidated_event: Optional[bool] = None,\n        supports_memory_event: Optional[bool] = None,\n        supports_args_can_be_interpreted_by_shell: Optional[bool] = None,\n        supports_start_debugging_request: Optional[bool] = None,\n    ) -&gt; int:\n        \"\"\"Initializes the debug adapter with the client capabilities.\"\"\"\n\n        return self.send_request(\n            \"initialize\",\n            {\n                \"adapterID\": adapter_id,\n                \"clientID\": client_id,\n                \"clientName\": client_name,\n                \"locale\": locale,\n                \"linesStartAt1\": lines_start_at1,\n                \"columnsStartAt1\": columns_start_at1,\n                \"pathFormat\": path_format,\n                \"supportsVariableType\": supports_variable_type,\n                \"supportsVariablePaging\": supports_variable_paging,\n                \"supportsRunInTerminalRequest\": supports_run_in_terminal_request,\n                \"supportsMemoryReferences\": supports_memory_references,\n                \"supportsProgressReporting\": supports_progress_reporting,\n                \"supportsInvalidatedEvent\": supports_invalidated_event,\n                \"supportsMemoryEvent\": supports_memory_event,\n                \"supportsArgsCanBeInterpretedByShell\": supports_args_can_be_interpreted_by_shell,\n                \"supportsStartDebuggingRequest\": supports_start_debugging_request,\n            },\n        )\n\n    def launch(\n        self,\n        no_debug: Optional[bool] = None,\n        __restart: Optional[Any] = None,\n    ) -&gt; int:\n        \"\"\"The launch request is used to start the debuggee with or without debugging enabled.\n\n        Args:\n            no_debug: Set to true if the launch request is used to just start the debuggee \\\n                for the purpose of collecting output. The debuggee is not supposed to stop at breakpoints.\n            __restart: Arbitrary data from the previous, restarted session. \\\n                The data is sent as the `restart` attribute of the `terminated` event.\n        \"\"\"\n\n        return self.send_request(\n            \"launch\",\n            {\"noDebug\": no_debug, \"__restart\": __restart},\n        )\n\n    def loaded_sources(self) -&gt; int:\n        \"\"\"Retrieves the set of all sources currently loaded by the debugged process.\"\"\"\n\n        return self.send_request(\"loadedSources\")\n\n    def modules(\n        self, start_module: Optional[int] = None, module_count: Optional[int] = None\n    ) -&gt; int:\n        \"\"\"Modules can be retrieved from the debug adapter with this request which can either\n        return all modules or a range of modules to support paging.\n\n        Args:\n            start_module: The 0-based index of the first module to return; if omitted modules start at 0.\n            module_count: The number of modules to return. If moduleCount is not specified or 0, \\\n                all modules are returned.\n        \"\"\"\n\n        return self.send_request(\n            \"modules\", {\"startModule\": start_module, \"moduleCount\": module_count}\n        )\n\n    def next(\n        self,\n        thread_id: int,\n        single_thread: Optional[bool] = None,\n        granularity: Optional[str] = None,\n    ) -&gt; int:\n        \"\"\"The request steps through the program.\n\n        Args:\n            thread_id: Specifies the thread for which to resume execution for one step.\n            single_thread: If this is true, all other suspended threads are not resumed.\n            granularity: The granularity of the step, assumed to be 'statement' if not specified.\n        \"\"\"\n\n        return self.send_request(\n            \"next\",\n            {\n                \"threadId\": thread_id,\n                \"singleThread\": single_thread,\n                \"granularity\": granularity,\n            },\n        )\n\n    def pause(self, thread_id: int) -&gt; int:\n        \"\"\"Suspends the debuggee.\n\n        Args:\n            thread_id: The thread to pause.\n        \"\"\"\n\n        return self.send_request(\"pause\", {\"threadId\": thread_id})\n\n    def read_memory(\n        self, memory_reference: str, count: int, offset: Optional[int] = None\n    ) -&gt; int:\n        \"\"\"Reads memory from the debuggee.\n\n        Args:\n            memory_reference: The memory reference to the base location from which to read memory.\n            count: The number of bytes to read at the specified location and offset.\n            offset: The offset (in bytes) of the first byte to read.\n        \"\"\"\n\n        return self.send_request(\n            \"readMemory\",\n            {\"memoryReference\": memory_reference, \"offset\": offset, \"count\": count},\n        )\n\n    def restart(\n        self,\n        arguments: Optional[LaunchRequestArguments | AttachRequestArguments] = None,\n    ) -&gt; int:\n        \"\"\"Restarts a debug session.\n\n        Args:\n            arguments: Use either arguments for the 'launch' or 'attach' request.\n        \"\"\"\n\n        return self.send_request(\"restart\", arguments)\n\n    def restart_frame(self, frame_id: int) -&gt; int:\n        \"\"\"Restart the stack frame identified by the given frame ID.\n        The frame ID must have been obtained in the current suspended state.\n\n        Args:\n            frame_id: The frame to restart.\n        \"\"\"\n\n        return self.send_request(\"restartFrame\", {\"frameId\": frame_id})\n\n    def reverse_continue(\n        self, thread_id: int, single_thread: Optional[bool] = None\n    ) -&gt; int:\n        \"\"\"The request starts the debuggee to run backward.\n\n        Args:\n            thread_id: ID of the active thread.\n            single_thread: If true, backward execution is limited to the specified thread.\n        \"\"\"\n\n        return self.send_request(\n            \"reverseContinue\",\n            {\"threadId\": thread_id, \"singleThread\": single_thread},\n        )\n\n    def scopes(self, frame_id: int) -&gt; int:\n        \"\"\"The request returns the variable scopes for a given stack frame.\n\n        Args:\n            frame_id: Retrieve the scopes for this stackframe.\n        \"\"\"\n\n        return self.send_request(\"scopes\", {\"frameId\": frame_id})\n\n    def set_breakpoints(\n        self,\n        source: Source,\n        breakpoints: List[SourceBreakpoint],\n        lines: Optional[List[int]] = None,\n        source_modified: Optional[bool] = None,\n    ) -&gt; int:\n        \"\"\"Sets multiple breakpoints for a single source and clears all previous breakpoints in that source.\n\n        Args:\n            source: The source location of the breakpoints.\n            breakpoints: The code locations of the breakpoints.\n            lines: Deprecated: The code locations of the breakpoints.\n            source_modified: A value of true indicates that the underlying source has been modified \\\n                which results in new breakpoint locations.\n        \"\"\"\n\n        return self.send_request(\n            \"setBreakpoints\",\n            {\n                \"source\": source,\n                \"breakpoints\": breakpoints,\n                \"lines\": lines,\n                \"sourceModified\": source_modified,\n            },\n        )\n\n    def set_data_breakpoints(self, breakpoints: List[DataBreakpoint]) -&gt; int:\n        \"\"\"Replaces all existing data breakpoints with new data breakpoints.\n\n        Args:\n            breakpoints: The data breakpoints to set.\n        \"\"\"\n\n        return self.send_request(\"setDataBreakpoints\", {\"breakpoints\": breakpoints})\n\n    def set_exception_breakpoints(\n        self,\n        filters: List[str],\n        filter_options: Optional[List[ExceptionFilterOptions]],\n        exception_options: Optional[List[ExceptionOptions]],\n    ) -&gt; int:\n        \"\"\"The request configures the debugger's response to thrown exceptions.\n\n        Each of the filters, filterOptions, and exceptionOptions in the request are independent configurations\n        to a debug adapter indicating a kind of exception to catch. An exception thrown in a program should result\n        in a stopped event from the debug adapter (with reason exception) if any of the configured filters match.\n\n        Args:\n            filters: Set of exception filters specified by their ID.\n            filter_options: An array of ExceptionFilterOptions. The set of all possible exception filters \\\n                is defined by the `exceptionBreakpointFilters` capability.\n            exception_options: An array of ExceptionOptions. Configuration options for selected exceptions.\n        \"\"\"\n\n        return self.send_request(\n            \"setExceptionBreakpoints\",\n            {\n                \"filters\": filters,\n                \"filterOptions\": filter_options,\n                \"exceptionOptions\": exception_options,\n            },\n        )\n\n    def set_expression(\n        self,\n        expression: str,\n        value: str,\n        frame_id: Optional[int] = None,\n        format: Optional[ValueFormat] = None,\n    ) -&gt; int:\n        \"\"\"Evaluates the given value expression and assigns it to the expression which must be a modifiable l-value.\n\n        The expressions have access to any variables and arguments that are in scope of the specified frame.\n\n        Args:\n            expression: The l-value expression to assign the result to.\n            value: The value expression to assign to the l-value expression.\n            frame_id: Evaluate the expressions in the scope of this stack frame. \\\n                If not specified, the expressions are evaluated in the global scope.\n            format: Specifies details on how to format the result.\n        \"\"\"\n\n        return self.send_request(\n            \"setExpression\",\n            {\n                \"expression\": expression,\n                \"value\": value,\n                \"frameId\": frame_id,\n                \"format\": format,\n            },\n        )\n\n    def set_function_breakpoints(\n        self, breakpoints: List[FunctionBreakpoint] = []\n    ) -&gt; int:\n        \"\"\"Replaces all existing function breakpoints with new function breakpoints.\n\n        To clear all function breakpoints, call this without arguments.\n        When a function breakpoint is hit, a stopped event (with reason function breakpoint) is generated.\n\n        Args:\n            breakpoints: The function breakpoints to set.\n        \"\"\"\n\n        return self.send_request(\"setFunctionBreakpoints\", {\"breakpoints\": breakpoints})\n\n    def set_instruction_breakpoints(\n        self, breakpoints: List[InstructionBreakpoint]\n    ) -&gt; int:\n        \"\"\"Replaces all existing instruction breakpoints. Typically, instruction breakpoints would be set from a disassembly window.\n\n        To clear all instruction breakpoints, specify an empty array.\n        When an instruction breakpoint is hit, a stopped event (with reason instruction breakpoint) is generated.\n\n        Args:\n            breakpoints: The instruction breakpoints to set.\n        \"\"\"\n\n        return self.send_request(\n            \"setInstructionBreakpoints\", {\"breakpoints\": breakpoints}\n        )\n\n    def set_variable(\n        self,\n        variables_reference: int,\n        name: str,\n        value: str,\n        format: Optional[ValueFormat] = None,\n    ) -&gt; int:\n        \"\"\"Set the variable with the given name in the variable container to a new value.\n\n        Args:\n            variables_reference: The reference of the variable container.\n            name: The name of the variable to set.\n            value: The value to set.\n            format: Specifies details on how to format the response value.\n        \"\"\"\n\n        return self.send_request(\n            \"setVariable\",\n            {\n                \"variablesReference\": variables_reference,\n                \"name\": name,\n                \"value\": value,\n                \"format\": format,\n            },\n        )\n\n    def source(self, source_reference: int, source: Optional[Source] = None) -&gt; int:\n        \"\"\"The request retrieves the source code for a given source reference.\n\n        Args:\n            source_reference: The reference to the source. This is the same as `source.sourceReference`.\n            source: Specifies the source content to load. Either `source.path` or `source.sourceReference` must be specified.\n        \"\"\"\n\n        return self.send_request(\n            \"source\", {\"sourceReference\": source_reference, \"source\": source}\n        )\n\n    def stack_trace(\n        self,\n        thread_id: Optional[int] = None,\n        start_frame: Optional[int] = None,\n        levels: Optional[int] = None,\n        format: Optional[StackFrameFormat] = None,\n    ) -&gt; int:\n        \"\"\"The request returns a stack trace from the current execution state.\n\n        Request all stack frames by omitting the startFrame and levels arguments.\n\n        Args:\n            thread_id: Retrieve the stacktrace for this thread.\n            start_frame: The index of the first frame to return; if omitted frames start at 0.\n            levels: The maximum number of frames to return. If levels is not specified or 0, all frames are returned.\n            format: Specifies details on how to format the stack frames.\n        \"\"\"\n\n        return self.send_request(\n            \"stackTrace\",\n            {\n                \"threadId\": thread_id,\n                \"startFrame\": start_frame,\n                \"levels\": levels,\n                \"format\": format,\n            },\n        )\n\n    def step_back(\n        self,\n        thread_id: int,\n        single_thread: Optional[bool] = None,\n        granularity: Optional[SteppingGranularity] = None,\n    ) -&gt; int:\n        \"\"\"The request executes one backward step (in the given granularity) for the specified thread\n        and allows all other threads to run backward freely by resuming them.\n\n        If the debug adapter supports single thread execution (see capability `supportsSingleThreadExecutionRequests`),\n        setting the singleThread argument to true prevents other suspended threads from resuming.\n        The debug adapter first sends the response and then a stopped event (with reason step) after the step has completed.\n\n        Args:\n            thread_id: ID of the active thread.\n            single_thread: If true, backward execution is limited to the specified thread.\n            granularity: The granularity of the step, assumed to be 'statement' if not specified.\n        \"\"\"\n\n        return self.send_request(\n            \"stepBack\",\n            {\n                \"threadId\": thread_id,\n                \"singleThread\": single_thread,\n                \"granularity\": granularity,\n            },\n        )\n\n    def step_in(\n        self,\n        thread_id: int,\n        single_thread: Optional[bool] = None,\n        target_id: Optional[int] = None,\n        granularity: Optional[SteppingGranularity] = None,\n    ) -&gt; int:\n        \"\"\"The request resumes the given thread to step into a function/method and allows all other threads to run freely by resuming them.\n\n        If the debug adapter supports single thread execution (see capability `supportsSingleThreadExecutionRequests`),\n        setting the singleThread argument to true prevents other suspended threads from resuming.\n\n        If the request cannot step into a target, stepIn behaves like the next request.\n        The debug adapter first sends the response and then a stopped event (with reason step) after the step has completed.\n\n        If there are multiple function/method calls (or other targets) on the source line,\n        the argument targetId can be used to control into which target the stepIn should occur.\n\n        Args:\n            thread_id: ID of the active thread.\n            single_thread: If true, stepIn is limited to the specified thread.\n            target_id: The stepIn target for this step.\n            granularity: The granularity of the step, assumed to be 'statement' if not specified.\n        \"\"\"\n\n        return self.send_request(\n            \"stepIn\",\n            {\n                \"threadId\": thread_id,\n                \"singleThread\": single_thread,\n                \"targetId\": target_id,\n                \"granularity\": granularity,\n            },\n        )\n\n    def step_in_targets(self, frame_id: int) -&gt; int:\n        \"\"\"The request retrieves the possible stepIn targets for the specified stack frame.\n        These targets can be used in the stepIn request.\n\n        Args:\n            frame_id: The stack frame for which to retrieve the possible stepIn targets.\n        \"\"\"\n\n        return self.send_request(\"stepInTargets\", {\"frameId\": frame_id})\n\n    def step_out(\n        self,\n        thread_id: int,\n        single_thread: Optional[bool] = None,\n        granularity: Optional[SteppingGranularity] = None,\n    ) -&gt; int:\n        \"\"\"The request resumes the given thread to step out of the current function/method and allows all other threads to run freely by resuming them.\n\n        If the debug adapter supports single thread execution (see capability `supportsSingleThreadExecutionRequests`),\n        setting the singleThread argument to true prevents other suspended threads from resuming.\n\n        The debug adapter first sends the response and then a stopped event (with reason step) after the step has completed.\n\n        Args:\n            thread_id: ID of the active thread.\n            single_thread: If true, stepOut is limited to the specified thread.\n            granularity: The granularity of the step, assumed to be 'statement' if not specified.\n        \"\"\"\n\n        return self.send_request(\n            \"stepOut\",\n            {\n                \"threadId\": thread_id,\n                \"singleThread\": single_thread,\n                \"granularity\": granularity,\n            },\n        )\n\n    def terminate(self, restart: Optional[bool] = None) -&gt; int:\n        \"\"\"The terminate request is sent from the client to the debug adapter in order to shut down the debuggee gracefully.\n\n        Typically a debug adapter implements terminate by sending a software signal which the debuggee intercepts in order\n        to clean things up properly before terminating itself.\n\n        Please note that this request does not directly affect the state of the debug session: if the debuggee decides to\n        veto the graceful shutdown for any reason by not terminating itself, then the debug session just continues.\n\n        Args:\n            restart: A value of true indicates that this 'terminate' request is part of a restart sequence.\n        \"\"\"\n\n        return self.send_request(\"terminate\", {\"restart\": restart})\n\n    def terminate_threads(self, thread_ids: List[int]) -&gt; int:\n        \"\"\"The request terminates the threads with the given ids.\n\n        Args:\n            thread_ids: The threads to terminate.\n        \"\"\"\n\n        return self.send_request(\"terminateThreads\", {\"threadIds\": thread_ids})\n\n    def threads(self) -&gt; int:\n        \"\"\"The request retrieves a list of all threads.\"\"\"\n\n        return self.send_request(\"threads\")\n\n    def variables(\n        self,\n        variables_reference: int,\n        filter: Optional[Literal[\"indexed\", \"named\"]] | str = None,\n        start: Optional[int] = None,\n        count: Optional[int] = None,\n        format: Optional[ValueFormat] = None,\n    ) -&gt; int:\n        \"\"\"Retrieves all child variables for the given variable reference.\n\n        A filter can be used to limit the fetched children to either named or indexed children.\n\n        Args:\n            variables_reference: The variable for which to retrieve its children.\n            filter: Filter to limit the child variables to either named or indexed. If not specified, both types are fetched.\n            start: The index of the first variable to return; if omitted variables start at 0.\n            count: The number of variables to return. If not passed or 0, all variables are returned.\n            format: Specifies details on how to format the response value.\n        \"\"\"\n\n        return self.send_request(\n            \"variables\",\n            {\n                \"variablesReference\": variables_reference,\n                \"filter\": filter,\n                \"start\": start,\n                \"count\": count,\n                \"format\": format,\n            },\n        )\n\n    def write_memory(\n        self,\n        memory_reference: str,\n        data: str,\n        offset: Optional[int] = None,\n        allow_partial: Optional[bool] = None,\n    ) -&gt; int:\n        \"\"\"Writes bytes to memory at the provided location.\n\n        Args:\n            memory_reference: The memory reference to the base location to write memory.\n            data: Bytes to write, encoded using base64.\n            offset: The offset (in bytes) of the first byte to write. Can be negative.\n            allow_partial: Property to control partial writes. If true, the debug adapter should \\\n                attempt to write memory even if the entire memory region is not writable.\n        \"\"\"\n\n        return self.send_request(\n            \"writeMemory\",\n            {\n                \"memoryReference\": memory_reference,\n                \"offset\": offset,\n                \"data\": data,\n                \"allowPartial\": allow_partial,\n            },\n        )\n</code></pre>"},{"location":"api-reference/#dap.client.Client.__init__","title":"<code>__init__(adapter_id, client_id=None, client_name=None, locale=None, lines_start_at1=None, columns_start_at1=None, path_format=None)</code>","text":"<p>Initializes the debug adapter client.</p> <p>Parameters:</p> Name Type Description Default <code>adapter_id</code> <code>str</code> <p>The ID of the debug adapter.</p> required <code>client_id</code> <code>Optional[str]</code> <p>The ID of the client.</p> <code>None</code> <code>client_name</code> <code>Optional[str]</code> <p>The name of the client.</p> <code>None</code> <code>locale</code> <code>Optional[str]</code> <p>The locale of the client.</p> <code>None</code> <code>lines_start_at1</code> <code>Optional[bool]</code> <p>Whether the lines start at 1.</p> <code>None</code> <code>columns_start_at1</code> <code>Optional[bool]</code> <p>Whether the columns start at 1.</p> <code>None</code> <code>path_format</code> <code>Optional[Literal[path, uri] | str]</code> <p>The format of the paths.</p> <code>None</code> Source code in <code>src\\dap\\client.py</code> <pre><code>def __init__(\n    self,\n    adapter_id: str,\n    client_id: Optional[str] = None,\n    client_name: Optional[str] = None,\n    locale: Optional[str] = None,\n    lines_start_at1: Optional[bool] = None,\n    columns_start_at1: Optional[bool] = None,\n    path_format: Optional[Literal[\"path\", \"uri\"] | str] = None,\n) -&gt; None:\n    \"\"\"Initializes the debug adapter client.\n\n    Args:\n        adapter_id: The ID of the debug adapter.\n        client_id: The ID of the client.\n        client_name: The name of the client.\n        locale: The locale of the client.\n        lines_start_at1: Whether the lines start at 1.\n        columns_start_at1: Whether the columns start at 1.\n        path_format: The format of the paths.\n    \"\"\"\n\n    self._seq: int = 1\n    self._send_buf = bytearray()\n    self._receive_buf = bytearray()\n    self._pending_requests: dict[int, Request] = {}\n\n    self.handler = Handler(self)\n\n    self.initialize(\n        adapter_id=adapter_id,\n        client_id=client_id,\n        client_name=client_name,\n        locale=locale,\n        lines_start_at1=lines_start_at1,\n        columns_start_at1=columns_start_at1,\n        path_format=path_format,\n        supports_variable_type=True,\n        supports_variable_paging=True,\n        supports_run_in_terminal_request=True,\n        supports_memory_references=True,\n        supports_progress_reporting=True,\n        supports_invalidated_event=True,\n        supports_memory_event=True,\n        supports_args_can_be_interpreted_by_shell=True,\n        supports_start_debugging_request=True,\n    )\n</code></pre>"},{"location":"api-reference/#dap.client.Client.attach","title":"<code>attach(__restart=None)</code>","text":"<p>attach to a running process.</p> <p>Parameters:</p> Name Type Description Default <code>__restart</code> <code>Optional[Any]</code> <p>Arbitrary data from the previous, restarted session.                 The data is sent as the <code>restart</code> attribute of the <code>terminated</code> event.</p> <code>None</code> Source code in <code>src\\dap\\client.py</code> <pre><code>def attach(self, __restart: Optional[Any] = None) -&gt; int:\n    \"\"\"attach to a running process.\n\n    Args:\n        __restart: Arbitrary data from the previous, restarted session. \\\n            The data is sent as the `restart` attribute of the `terminated` event.\"\"\"\n\n    return self.send_request(\"attach\", {\"__restart\": __restart})\n</code></pre>"},{"location":"api-reference/#dap.client.Client.breakpoint_locations","title":"<code>breakpoint_locations(source, line, column=None, end_line=None, end_column=None)</code>","text":"<p>Retrieve all possible locations for source breakpoints in a given range.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Source</code> <p>The source location of the breakpoints.</p> required <code>line</code> <code>int</code> <p>The source line of the breakpoints.</p> required <code>column</code> <code>Optional[int]</code> <p>An optional source column of the breakpoints.</p> <code>None</code> <code>end_line</code> <code>Optional[int]</code> <p>An optional end line of the range covered by the breakpoint.</p> <code>None</code> <code>end_column</code> <code>Optional[int]</code> <p>An optional end column of the range covered by the breakpoint.</p> <code>None</code> Source code in <code>src\\dap\\client.py</code> <pre><code>def breakpoint_locations(\n    self,\n    source: Source,\n    line: int,\n    column: Optional[int] = None,\n    end_line: Optional[int] = None,\n    end_column: Optional[int] = None,\n) -&gt; int:\n    \"\"\"Retrieve all possible locations for source breakpoints in a given range.\n\n    Args:\n        source: The source location of the breakpoints.\n        line: The source line of the breakpoints.\n        column: An optional source column of the breakpoints.\n        end_line: An optional end line of the range covered by the breakpoint.\n        end_column: An optional end column of the range covered by the breakpoint.\n    \"\"\"\n\n    return self.send_request(\n        \"breakpointLocations\",\n        {\n            \"source\": source,\n            \"line\": line,\n            \"column\": column,\n            \"endLine\": end_line,\n            \"endColumn\": end_column,\n        },\n    )\n</code></pre>"},{"location":"api-reference/#dap.client.Client.cancel","title":"<code>cancel(request_id=None, progress_id=None)</code>","text":"<p>The cancel request is used by the client in two situations:</p> <ul> <li>to indicate that it is no longer interested in the result produced by a specific request issued earlier</li> <li>to cancel a progress sequence.</li> </ul> <p>Both <code>progress_id</code> and <code>request_id</code> CAN BE specified in the same request.</p> <p>Parameters:</p> Name Type Description Default <code>request_id</code> <code>Optional[int]</code> <p>The ID (_seq) of the request to cancel. If missing no request is canceled.</p> <code>None</code> <code>progress_id</code> <code>Optional[str]</code> <p>The progress ID of the progress sequence to cancel. If missing no progress is canceled.</p> <code>None</code> Source code in <code>src\\dap\\client.py</code> <pre><code>def cancel(\n    self, request_id: Optional[int] = None, progress_id: Optional[str] = None\n) -&gt; int:\n    \"\"\"The cancel request is used by the client in two situations:\n\n    - to indicate that it is no longer interested in the result produced by a specific request issued earlier\n    - to cancel a progress sequence.\n\n    Both `progress_id` and `request_id` CAN BE specified in the same request.\n\n    Args:\n        request_id: The ID (_seq) of the request to cancel. If missing no request is canceled.\n        progress_id: The progress ID of the progress sequence to cancel. If missing no progress is canceled.\n    \"\"\"\n\n    return self.send_request(\n        \"cancel\", {\"requestId\": request_id, \"progressId\": progress_id}\n    )\n</code></pre>"},{"location":"api-reference/#dap.client.Client.completions","title":"<code>completions(text, column, line, frame_id=None)</code>","text":"<p>Returns a list of possible completions for a given caret position and text.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>One or more source lines. Typically this is the text users have typed into                 the debug console before they asked for completion.</p> required <code>column</code> <code>int</code> <p>The position within <code>text</code> for which to determine the completion proposals.</p> required <code>line</code> <code>Optional[int]</code> <p>A line for which to determine the completion proposals. If missing the                 first line of the text is assumed.</p> required <code>frame_id</code> <code>Optional[int]</code> <p>An optional frameId of the stack frame, if specified returns                 completions in the scope of this stack frame.</p> <code>None</code> Source code in <code>src\\dap\\client.py</code> <pre><code>def completions(\n    self,\n    text: str,\n    column: int,\n    line: Optional[int],\n    frame_id: Optional[int] = None,\n) -&gt; int:\n    \"\"\"Returns a list of possible completions for a given caret position and text.\n\n    Args:\n        text: One or more source lines. Typically this is the text users have typed into \\\n            the debug console before they asked for completion.\n        column: The position within `text` for which to determine the completion proposals.\n        line: A line for which to determine the completion proposals. If missing the \\\n            first line of the text is assumed.\n        frame_id: An optional frameId of the stack frame, if specified returns \\\n            completions in the scope of this stack frame.\n    \"\"\"\n\n    return self.send_request(\n        \"completions\",\n        {\n            \"frameId\": frame_id,\n            \"text\": text,\n            \"column\": column,\n            \"line\": line,\n        },\n    )\n</code></pre>"},{"location":"api-reference/#dap.client.Client.configuration_done","title":"<code>configuration_done()</code>","text":"<p>This request indicates that the client has finished initialization of the debug adapter.</p> Source code in <code>src\\dap\\client.py</code> <pre><code>def configuration_done(self) -&gt; int:\n    \"\"\"This request indicates that the client has finished initialization of the debug adapter.\"\"\"\n\n    return self.send_request(\"configurationDone\")\n</code></pre>"},{"location":"api-reference/#dap.client.Client.continue_","title":"<code>continue_(thread_id, single_thread=None)</code>","text":"<p>The request resumes execution of all threads. If the debug adapter supports single thread execution, setting <code>single_thread</code> true resumes only the specified thread.</p> <p>Parameters:</p> Name Type Description Default <code>thread_id</code> <code>int</code> <p>the active thread.</p> required <code>single_thread</code> <code>Optional[bool]</code> <p>Execute only this thread.</p> <code>None</code> Source code in <code>src\\dap\\client.py</code> <pre><code>def continue_(self, thread_id: int, single_thread: Optional[bool] = None) -&gt; int:\n    \"\"\"The request resumes execution of all threads.\n    If the debug adapter supports single thread execution, setting `single_thread` true resumes only the specified thread.\n\n    Args:\n        thread_id: the active thread.\n        single_thread: Execute only this thread.\n    \"\"\"\n\n    return self.send_request(\n        \"continue\", {\"threadId\": thread_id, \"singleThread\": single_thread}\n    )\n</code></pre>"},{"location":"api-reference/#dap.client.Client.data_breakpoint_info","title":"<code>data_breakpoint_info(name, variables_reference=None, frameId=None, bytes=None, asAddress=None, mode=None)</code>","text":"<p>Retrieve the information of a data breakpoint.</p> <p>Parameters:</p> Name Type Description Default <code>variables_reference</code> <code>Optional[int]</code> <p>Reference to the variable container if the data breakpoint is requested for                 a child of the container.</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the variable's child to obtain data breakpoint information for.</p> required <code>frameId</code> <code>Optional[int]</code> <p>When <code>name</code> is an expression, evaluate it in the scope of this stack frame.</p> <code>None</code> <code>bytes</code> <code>Optional[int]</code> <p>If specified, a debug adapter should return information for the range of memory extending                 <code>bytes</code> number of bytes from the address or variable specified by <code>name</code>.                 Breakpoints set using the resulting data ID should pause on data access anywhere within that range.</p> <code>None</code> <code>asAddress</code> <code>Optional[bool]</code> <p>If true, <code>name</code> is an address.</p> <code>None</code> <code>mode</code> <code>Optional[str]</code> <p>The mode of the desired breakpoint.</p> <code>None</code> Source code in <code>src\\dap\\client.py</code> <pre><code>def data_breakpoint_info(\n    self,\n    name: str,\n    variables_reference: Optional[int] = None,\n    frameId: Optional[int] = None,\n    bytes: Optional[int] = None,\n    asAddress: Optional[bool] = None,\n    mode: Optional[str] = None,\n) -&gt; int:\n    \"\"\"Retrieve the information of a data breakpoint.\n\n    Args:\n        variables_reference: Reference to the variable container if the data breakpoint is requested for \\\n            a child of the container.\n        name: The name of the variable's child to obtain data breakpoint information for.\n        frameId: When `name` is an expression, evaluate it in the scope of this stack frame.\n        bytes: If specified, a debug adapter should return information for the range of memory extending \\\n            `bytes` number of bytes from the address or variable specified by `name`. \\\n            Breakpoints set using the resulting data ID should pause on data access anywhere within that range.\n        asAddress: If true, `name` is an address.\n        mode: The mode of the desired breakpoint.\n    \"\"\"\n\n    return self.send_request(\n        \"dataBreakpointInfo\",\n        {\n            \"variablesReference\": variables_reference,\n            \"name\": name,\n            \"frameId\": frameId,\n            \"bytes\": bytes,\n            \"asAddress\": asAddress,\n            \"mode\": mode,\n        },\n    )\n</code></pre>"},{"location":"api-reference/#dap.client.Client.disassemble","title":"<code>disassemble(memory_reference, instruction_count=None, offset=None, instruction_offset=None, resolve_symbols=None)</code>","text":"<p>Disassembles code stored at the provided location.</p> <p>Parameters:</p> Name Type Description Default <code>memory_reference</code> <code>str</code> <p>Memory reference to the base location containing the instructions to disassemble.</p> required <code>instruction_count</code> <code>Optional[int]</code> <p>The number of instructions to disassemble starting at the specified location and offset.</p> <code>None</code> <code>offset</code> <code>Optional[int]</code> <p>The offset (in bytes) of the first instruction to disassemble.</p> <code>None</code> <code>instruction_offset</code> <code>Optional[int]</code> <p>The offset (in instructions) of the first instruction to disassemble.</p> <code>None</code> <code>resolve_symbols</code> <code>Optional[bool]</code> <p>If set to true, the adapter should attempt to resolve memory addresses                 to function names and line numbers.</p> <code>None</code> Source code in <code>src\\dap\\client.py</code> <pre><code>def disassemble(\n    self,\n    memory_reference: str,\n    instruction_count: Optional[int] = None,\n    offset: Optional[int] = None,\n    instruction_offset: Optional[int] = None,\n    resolve_symbols: Optional[bool] = None,\n) -&gt; int:\n    \"\"\"Disassembles code stored at the provided location.\n\n    Args:\n        memory_reference: Memory reference to the base location containing the instructions to disassemble.\n        instruction_count: The number of instructions to disassemble starting at the specified location and offset.\n        offset: The offset (in bytes) of the first instruction to disassemble.\n        instruction_offset: The offset (in instructions) of the first instruction to disassemble.\n        resolve_symbols: If set to true, the adapter should attempt to resolve memory addresses \\\n            to function names and line numbers.\n    \"\"\"\n\n    return self.send_request(\n        \"disassemble\",\n        {\n            \"memoryReference\": memory_reference,\n            \"offset\": offset,\n            \"instructionCount\": instruction_count,\n        },\n    )\n</code></pre>"},{"location":"api-reference/#dap.client.Client.disconnect","title":"<code>disconnect(restart=None, terminal_debuggee=None, suspend_debuggee=None)</code>","text":"<p>Asks the debug adapter to disconnect from the debuggee (thus ending the debug session) and then to shut down.</p> <p>In addition, the debug adapter must terminate the debuggee if it was started with the launch request. If an attach request was used to connect to the debuggee, then the debug adapter must not terminate the debuggee.</p> <p>Parameters:</p> Name Type Description Default <code>restart</code> <code>Optional[bool]</code> <p>A value of true indicates that this 'disconnect' request is part of a restart sequence.</p> <code>None</code> <code>terminal_debuggee</code> <code>Optional[bool]</code> <p>Indicates whether the debuggee should be terminated when the debugger is disconnected.</p> <code>None</code> <code>suspend_debuggee</code> <code>Optional[bool]</code> <p>Indicates whether the debuggee should be allowed to run after the debugger is disconnected.</p> <code>None</code> Source code in <code>src\\dap\\client.py</code> <pre><code>def disconnect(\n    self,\n    restart: Optional[bool] = None,\n    terminal_debuggee: Optional[bool] = None,\n    suspend_debuggee: Optional[bool] = None,\n) -&gt; int:\n    \"\"\"Asks the debug adapter to disconnect from the debuggee (thus ending the debug session) and then to shut down.\n\n    In addition, the debug adapter must terminate the debuggee if it was started with the launch request.\n    If an attach request was used to connect to the debuggee, then the debug adapter must not terminate the debuggee.\n\n    Args:\n        restart: A value of true indicates that this 'disconnect' request is part of a restart sequence.\n        terminal_debuggee: Indicates whether the debuggee should be terminated when the debugger is disconnected.\n        suspend_debuggee: Indicates whether the debuggee should be allowed to run after the debugger is disconnected.\n    \"\"\"\n\n    return self.send_request(\n        \"disconnect\",\n        {\n            \"restart\": restart,\n            \"terminateDebuggee\": terminal_debuggee,\n            \"suspendDebuggee\": suspend_debuggee,\n        },\n    )\n</code></pre>"},{"location":"api-reference/#dap.client.Client.evaluate","title":"<code>evaluate(expression, frame_id=None, line=None, column=None, source=None, context=None, format=None)</code>","text":"<p>Evaluate the given expression in the context of topmost stack frame. The expression has access to any variables and arguments that are in scope.</p> <p>Parameters:</p> Name Type Description Default <code>expression</code> <code>str</code> <p>The expression to evaluate.</p> required <code>frame_id</code> <code>Optional[int]</code> <p>Evaluate the expression in the scope of this stack frame.                 If not specified, the expression is evaluated in the global scope.</p> <code>None</code> <code>line</code> <code>Optional[int]</code> <p>The contextual line where the expression should be evaluated.                 In the 'hover' context, this should be set to the start of the expression being hovered.</p> <code>None</code> <code>column</code> <code>Optional[int]</code> <p>The contextual column where the expression should be evaluated.                 This may be provided if <code>line</code> is also provided.</p> <code>None</code> <code>source</code> <code>Optional[Source]</code> <p>The contextual source in which the <code>line</code> is found.                 This must be provided if <code>line</code> is provided.</p> <code>None</code> <code>context</code> <code>Optional[Literal[watch, repl, hover, clipboard, variables] | str]</code> <p>The context in which the evaluate request is used.</p> <code>None</code> <code>format</code> <code>Optional[ValueFormat]</code> <p>Specifies details on how to format the result.</p> <code>None</code> Source code in <code>src\\dap\\client.py</code> <pre><code>def evaluate(\n    self,\n    expression: str,\n    frame_id: Optional[int] = None,\n    line: Optional[int] = None,\n    column: Optional[int] = None,\n    source: Optional[Source] = None,\n    context: Optional[\n        Literal[\"watch\", \"repl\", \"hover\", \"clipboard\", \"variables\"] | str\n    ] = None,\n    format: Optional[ValueFormat] = None,\n) -&gt; int:\n    \"\"\"Evaluate the given expression in the context of topmost stack frame.\n    The expression has access to any variables and arguments that are in scope.\n\n    Args:\n        expression: The expression to evaluate.\n        frame_id: Evaluate the expression in the scope of this stack frame. \\\n            If not specified, the expression is evaluated in the global scope.\n        line: The contextual line where the expression should be evaluated. \\\n            In the 'hover' context, this should be set to the start of the expression being hovered.\n        column: The contextual column where the expression should be evaluated. \\\n            This may be provided if `line` is also provided.\n        source: The contextual source in which the `line` is found. \\\n            This must be provided if `line` is provided.\n        context: The context in which the evaluate request is used.\n        format: Specifies details on how to format the result.\n    \"\"\"\n\n    return self.send_request(\n        \"evaluate\",\n        {\n            \"expression\": expression,\n            \"frameId\": frame_id,\n            \"line\": line,\n            \"column\": column,\n            \"source\": source,\n            \"context\": context,\n            \"format\": format,\n        },\n    )\n</code></pre>"},{"location":"api-reference/#dap.client.Client.exception_info","title":"<code>exception_info(thread_id)</code>","text":"<p>Retrieves the details of the exception that caused this event to be raised.</p> <p>Parameters:</p> Name Type Description Default <code>thread_id</code> <code>int</code> <p>Thread for which exception information should be retrieved.</p> required Source code in <code>src\\dap\\client.py</code> <pre><code>def exception_info(self, thread_id: int) -&gt; int:\n    \"\"\"Retrieves the details of the exception that caused this event to be raised.\n\n    Args:\n        thread_id: Thread for which exception information should be retrieved.\n    \"\"\"\n\n    return self.send_request(\"exceptionInfo\", {\"threadId\": thread_id})\n</code></pre>"},{"location":"api-reference/#dap.client.Client.goto","title":"<code>goto(thread_id, target_id)</code>","text":"<p>The request sets the location where the debuggee will continue to run.</p> <p>Parameters:</p> Name Type Description Default <code>thread_id</code> <code>int</code> <p>The thread to continue.</p> required <code>target_id</code> <code>str</code> <p>The location where the debuggee will continue to run.</p> required Source code in <code>src\\dap\\client.py</code> <pre><code>def goto(self, thread_id: int, target_id: str) -&gt; int:\n    \"\"\"The request sets the location where the debuggee will continue to run.\n\n    Args:\n        thread_id: The thread to continue.\n        target_id: The location where the debuggee will continue to run.\n    \"\"\"\n\n    return self.send_request(\"goto\", {\"threadId\": thread_id, \"targetId\": target_id})\n</code></pre>"},{"location":"api-reference/#dap.client.Client.goto_targets","title":"<code>goto_targets(source, line, column=None)</code>","text":"<p>Retrieve possible goto targets for the specified location.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Source</code> <p>The source location for which the goto targets are determined.</p> required <code>line</code> <code>int</code> <p>The line for which the goto targets are determined.</p> required <code>column</code> <code>Optional[int]</code> <p>An optional column for which the goto targets are determined.</p> <code>None</code> Source code in <code>src\\dap\\client.py</code> <pre><code>def goto_targets(\n    self, source: Source, line: int, column: Optional[int] = None\n) -&gt; int:\n    \"\"\"Retrieve possible goto targets for the specified location.\n\n    Args:\n        source: The source location for which the goto targets are determined.\n        line: The line for which the goto targets are determined.\n        column: An optional column for which the goto targets are determined.\n    \"\"\"\n\n    return self.send_request(\n        \"gotoTargets\", {\"source\": source, \"line\": line, \"column\": column}\n    )\n</code></pre>"},{"location":"api-reference/#dap.client.Client.initialize","title":"<code>initialize(adapter_id, client_id=None, client_name=None, locale=None, lines_start_at1=None, columns_start_at1=None, path_format=None, supports_variable_type=None, supports_variable_paging=None, supports_run_in_terminal_request=None, supports_memory_references=None, supports_progress_reporting=None, supports_invalidated_event=None, supports_memory_event=None, supports_args_can_be_interpreted_by_shell=None, supports_start_debugging_request=None)</code>","text":"<p>Initializes the debug adapter with the client capabilities.</p> Source code in <code>src\\dap\\client.py</code> <pre><code>def initialize(\n    self,\n    adapter_id: str,\n    client_id: Optional[str] = None,\n    client_name: Optional[str] = None,\n    locale: Optional[str] = None,\n    lines_start_at1: Optional[bool] = None,\n    columns_start_at1: Optional[bool] = None,\n    path_format: Optional[Literal[\"path\", \"uri\"] | str] = None,\n    supports_variable_type: Optional[bool] = None,\n    supports_variable_paging: Optional[bool] = None,\n    supports_run_in_terminal_request: Optional[bool] = None,\n    supports_memory_references: Optional[bool] = None,\n    supports_progress_reporting: Optional[bool] = None,\n    supports_invalidated_event: Optional[bool] = None,\n    supports_memory_event: Optional[bool] = None,\n    supports_args_can_be_interpreted_by_shell: Optional[bool] = None,\n    supports_start_debugging_request: Optional[bool] = None,\n) -&gt; int:\n    \"\"\"Initializes the debug adapter with the client capabilities.\"\"\"\n\n    return self.send_request(\n        \"initialize\",\n        {\n            \"adapterID\": adapter_id,\n            \"clientID\": client_id,\n            \"clientName\": client_name,\n            \"locale\": locale,\n            \"linesStartAt1\": lines_start_at1,\n            \"columnsStartAt1\": columns_start_at1,\n            \"pathFormat\": path_format,\n            \"supportsVariableType\": supports_variable_type,\n            \"supportsVariablePaging\": supports_variable_paging,\n            \"supportsRunInTerminalRequest\": supports_run_in_terminal_request,\n            \"supportsMemoryReferences\": supports_memory_references,\n            \"supportsProgressReporting\": supports_progress_reporting,\n            \"supportsInvalidatedEvent\": supports_invalidated_event,\n            \"supportsMemoryEvent\": supports_memory_event,\n            \"supportsArgsCanBeInterpretedByShell\": supports_args_can_be_interpreted_by_shell,\n            \"supportsStartDebuggingRequest\": supports_start_debugging_request,\n        },\n    )\n</code></pre>"},{"location":"api-reference/#dap.client.Client.launch","title":"<code>launch(no_debug=None, __restart=None)</code>","text":"<p>The launch request is used to start the debuggee with or without debugging enabled.</p> <p>Parameters:</p> Name Type Description Default <code>no_debug</code> <code>Optional[bool]</code> <p>Set to true if the launch request is used to just start the debuggee                 for the purpose of collecting output. The debuggee is not supposed to stop at breakpoints.</p> <code>None</code> <code>__restart</code> <code>Optional[Any]</code> <p>Arbitrary data from the previous, restarted session.                 The data is sent as the <code>restart</code> attribute of the <code>terminated</code> event.</p> <code>None</code> Source code in <code>src\\dap\\client.py</code> <pre><code>def launch(\n    self,\n    no_debug: Optional[bool] = None,\n    __restart: Optional[Any] = None,\n) -&gt; int:\n    \"\"\"The launch request is used to start the debuggee with or without debugging enabled.\n\n    Args:\n        no_debug: Set to true if the launch request is used to just start the debuggee \\\n            for the purpose of collecting output. The debuggee is not supposed to stop at breakpoints.\n        __restart: Arbitrary data from the previous, restarted session. \\\n            The data is sent as the `restart` attribute of the `terminated` event.\n    \"\"\"\n\n    return self.send_request(\n        \"launch\",\n        {\"noDebug\": no_debug, \"__restart\": __restart},\n    )\n</code></pre>"},{"location":"api-reference/#dap.client.Client.loaded_sources","title":"<code>loaded_sources()</code>","text":"<p>Retrieves the set of all sources currently loaded by the debugged process.</p> Source code in <code>src\\dap\\client.py</code> <pre><code>def loaded_sources(self) -&gt; int:\n    \"\"\"Retrieves the set of all sources currently loaded by the debugged process.\"\"\"\n\n    return self.send_request(\"loadedSources\")\n</code></pre>"},{"location":"api-reference/#dap.client.Client.modules","title":"<code>modules(start_module=None, module_count=None)</code>","text":"<p>Modules can be retrieved from the debug adapter with this request which can either return all modules or a range of modules to support paging.</p> <p>Parameters:</p> Name Type Description Default <code>start_module</code> <code>Optional[int]</code> <p>The 0-based index of the first module to return; if omitted modules start at 0.</p> <code>None</code> <code>module_count</code> <code>Optional[int]</code> <p>The number of modules to return. If moduleCount is not specified or 0,                 all modules are returned.</p> <code>None</code> Source code in <code>src\\dap\\client.py</code> <pre><code>def modules(\n    self, start_module: Optional[int] = None, module_count: Optional[int] = None\n) -&gt; int:\n    \"\"\"Modules can be retrieved from the debug adapter with this request which can either\n    return all modules or a range of modules to support paging.\n\n    Args:\n        start_module: The 0-based index of the first module to return; if omitted modules start at 0.\n        module_count: The number of modules to return. If moduleCount is not specified or 0, \\\n            all modules are returned.\n    \"\"\"\n\n    return self.send_request(\n        \"modules\", {\"startModule\": start_module, \"moduleCount\": module_count}\n    )\n</code></pre>"},{"location":"api-reference/#dap.client.Client.next","title":"<code>next(thread_id, single_thread=None, granularity=None)</code>","text":"<p>The request steps through the program.</p> <p>Parameters:</p> Name Type Description Default <code>thread_id</code> <code>int</code> <p>Specifies the thread for which to resume execution for one step.</p> required <code>single_thread</code> <code>Optional[bool]</code> <p>If this is true, all other suspended threads are not resumed.</p> <code>None</code> <code>granularity</code> <code>Optional[str]</code> <p>The granularity of the step, assumed to be 'statement' if not specified.</p> <code>None</code> Source code in <code>src\\dap\\client.py</code> <pre><code>def next(\n    self,\n    thread_id: int,\n    single_thread: Optional[bool] = None,\n    granularity: Optional[str] = None,\n) -&gt; int:\n    \"\"\"The request steps through the program.\n\n    Args:\n        thread_id: Specifies the thread for which to resume execution for one step.\n        single_thread: If this is true, all other suspended threads are not resumed.\n        granularity: The granularity of the step, assumed to be 'statement' if not specified.\n    \"\"\"\n\n    return self.send_request(\n        \"next\",\n        {\n            \"threadId\": thread_id,\n            \"singleThread\": single_thread,\n            \"granularity\": granularity,\n        },\n    )\n</code></pre>"},{"location":"api-reference/#dap.client.Client.pause","title":"<code>pause(thread_id)</code>","text":"<p>Suspends the debuggee.</p> <p>Parameters:</p> Name Type Description Default <code>thread_id</code> <code>int</code> <p>The thread to pause.</p> required Source code in <code>src\\dap\\client.py</code> <pre><code>def pause(self, thread_id: int) -&gt; int:\n    \"\"\"Suspends the debuggee.\n\n    Args:\n        thread_id: The thread to pause.\n    \"\"\"\n\n    return self.send_request(\"pause\", {\"threadId\": thread_id})\n</code></pre>"},{"location":"api-reference/#dap.client.Client.read_memory","title":"<code>read_memory(memory_reference, count, offset=None)</code>","text":"<p>Reads memory from the debuggee.</p> <p>Parameters:</p> Name Type Description Default <code>memory_reference</code> <code>str</code> <p>The memory reference to the base location from which to read memory.</p> required <code>count</code> <code>int</code> <p>The number of bytes to read at the specified location and offset.</p> required <code>offset</code> <code>Optional[int]</code> <p>The offset (in bytes) of the first byte to read.</p> <code>None</code> Source code in <code>src\\dap\\client.py</code> <pre><code>def read_memory(\n    self, memory_reference: str, count: int, offset: Optional[int] = None\n) -&gt; int:\n    \"\"\"Reads memory from the debuggee.\n\n    Args:\n        memory_reference: The memory reference to the base location from which to read memory.\n        count: The number of bytes to read at the specified location and offset.\n        offset: The offset (in bytes) of the first byte to read.\n    \"\"\"\n\n    return self.send_request(\n        \"readMemory\",\n        {\"memoryReference\": memory_reference, \"offset\": offset, \"count\": count},\n    )\n</code></pre>"},{"location":"api-reference/#dap.client.Client.receive","title":"<code>receive(data)</code>","text":"<p>Feed data from the debug adapter to the client.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>The data to receive.</p> required <p>Yields:</p> Type Description <code>ResponseBody | EventBody</code> <p>The response or event body.</p> Source code in <code>src\\dap\\client.py</code> <pre><code>def receive(self, data: bytes) -&gt; Generator[ResponseBody | EventBody, None, None]:\n    \"\"\"Feed data from the debug adapter to the client.\n\n    Args:\n        data: The data to receive.\n\n    Yields:\n        The response or event body.\n    \"\"\"\n\n    self._receive_buf += data\n    yield from self.handler.handle()\n</code></pre>"},{"location":"api-reference/#dap.client.Client.restart","title":"<code>restart(arguments=None)</code>","text":"<p>Restarts a debug session.</p> <p>Parameters:</p> Name Type Description Default <code>arguments</code> <code>Optional[LaunchRequestArguments | AttachRequestArguments]</code> <p>Use either arguments for the 'launch' or 'attach' request.</p> <code>None</code> Source code in <code>src\\dap\\client.py</code> <pre><code>def restart(\n    self,\n    arguments: Optional[LaunchRequestArguments | AttachRequestArguments] = None,\n) -&gt; int:\n    \"\"\"Restarts a debug session.\n\n    Args:\n        arguments: Use either arguments for the 'launch' or 'attach' request.\n    \"\"\"\n\n    return self.send_request(\"restart\", arguments)\n</code></pre>"},{"location":"api-reference/#dap.client.Client.restart_frame","title":"<code>restart_frame(frame_id)</code>","text":"<p>Restart the stack frame identified by the given frame ID. The frame ID must have been obtained in the current suspended state.</p> <p>Parameters:</p> Name Type Description Default <code>frame_id</code> <code>int</code> <p>The frame to restart.</p> required Source code in <code>src\\dap\\client.py</code> <pre><code>def restart_frame(self, frame_id: int) -&gt; int:\n    \"\"\"Restart the stack frame identified by the given frame ID.\n    The frame ID must have been obtained in the current suspended state.\n\n    Args:\n        frame_id: The frame to restart.\n    \"\"\"\n\n    return self.send_request(\"restartFrame\", {\"frameId\": frame_id})\n</code></pre>"},{"location":"api-reference/#dap.client.Client.reverse_continue","title":"<code>reverse_continue(thread_id, single_thread=None)</code>","text":"<p>The request starts the debuggee to run backward.</p> <p>Parameters:</p> Name Type Description Default <code>thread_id</code> <code>int</code> <p>ID of the active thread.</p> required <code>single_thread</code> <code>Optional[bool]</code> <p>If true, backward execution is limited to the specified thread.</p> <code>None</code> Source code in <code>src\\dap\\client.py</code> <pre><code>def reverse_continue(\n    self, thread_id: int, single_thread: Optional[bool] = None\n) -&gt; int:\n    \"\"\"The request starts the debuggee to run backward.\n\n    Args:\n        thread_id: ID of the active thread.\n        single_thread: If true, backward execution is limited to the specified thread.\n    \"\"\"\n\n    return self.send_request(\n        \"reverseContinue\",\n        {\"threadId\": thread_id, \"singleThread\": single_thread},\n    )\n</code></pre>"},{"location":"api-reference/#dap.client.Client.scopes","title":"<code>scopes(frame_id)</code>","text":"<p>The request returns the variable scopes for a given stack frame.</p> <p>Parameters:</p> Name Type Description Default <code>frame_id</code> <code>int</code> <p>Retrieve the scopes for this stackframe.</p> required Source code in <code>src\\dap\\client.py</code> <pre><code>def scopes(self, frame_id: int) -&gt; int:\n    \"\"\"The request returns the variable scopes for a given stack frame.\n\n    Args:\n        frame_id: Retrieve the scopes for this stackframe.\n    \"\"\"\n\n    return self.send_request(\"scopes\", {\"frameId\": frame_id})\n</code></pre>"},{"location":"api-reference/#dap.client.Client.send","title":"<code>send()</code>","text":"<p>Get the data to send to the debug adapter.</p> <p>Returns:</p> Type Description <code>bytes</code> <p>The data to send.</p> Source code in <code>src\\dap\\client.py</code> <pre><code>def send(self) -&gt; bytes:\n    \"\"\"Get the data to send to the debug adapter.\n\n    Returns:\n        The data to send.\n    \"\"\"\n\n    send_buf = self._send_buf\n    self._send_buf = bytearray()\n    return send_buf\n</code></pre>"},{"location":"api-reference/#dap.client.Client.send_request","title":"<code>send_request(command, arguments=None)</code>","text":"<p>Send a request to the debug adapter.</p> <p>This can be useful for sending requests that are not yet implemented in the client or for sending custom requests to the debug adapter that are specific to the adapter.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str</code> <p>The command to send.</p> required <code>arguments</code> <code>Optional[dict[str, Any]]</code> <p>The arguments to send.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The sequence number of the request.</p> Source code in <code>src\\dap\\client.py</code> <pre><code>def send_request(\n    self, command: str, arguments: Optional[dict[str, Any]] = None\n) -&gt; int:\n    \"\"\"Send a request to the debug adapter.\n\n    This can be useful for sending requests that are not yet implemented in the client or\n    for sending custom requests to the debug adapter that are specific to the adapter.\n\n    Args:\n        command: The command to send.\n        arguments: The arguments to send.\n\n    Returns:\n        The sequence number of the request.\n    \"\"\"\n\n    seq = self._seq\n    self._seq += 1\n\n    self._send_buf += RequestBuffer(seq, command, arguments)\n    self._pending_requests[seq] = Request(\n        seq=seq, command=command, arguments=arguments\n    )\n    return seq\n</code></pre>"},{"location":"api-reference/#dap.client.Client.set_breakpoints","title":"<code>set_breakpoints(source, breakpoints, lines=None, source_modified=None)</code>","text":"<p>Sets multiple breakpoints for a single source and clears all previous breakpoints in that source.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Source</code> <p>The source location of the breakpoints.</p> required <code>breakpoints</code> <code>List[SourceBreakpoint]</code> <p>The code locations of the breakpoints.</p> required <code>lines</code> <code>Optional[List[int]]</code> <p>Deprecated: The code locations of the breakpoints.</p> <code>None</code> <code>source_modified</code> <code>Optional[bool]</code> <p>A value of true indicates that the underlying source has been modified                 which results in new breakpoint locations.</p> <code>None</code> Source code in <code>src\\dap\\client.py</code> <pre><code>def set_breakpoints(\n    self,\n    source: Source,\n    breakpoints: List[SourceBreakpoint],\n    lines: Optional[List[int]] = None,\n    source_modified: Optional[bool] = None,\n) -&gt; int:\n    \"\"\"Sets multiple breakpoints for a single source and clears all previous breakpoints in that source.\n\n    Args:\n        source: The source location of the breakpoints.\n        breakpoints: The code locations of the breakpoints.\n        lines: Deprecated: The code locations of the breakpoints.\n        source_modified: A value of true indicates that the underlying source has been modified \\\n            which results in new breakpoint locations.\n    \"\"\"\n\n    return self.send_request(\n        \"setBreakpoints\",\n        {\n            \"source\": source,\n            \"breakpoints\": breakpoints,\n            \"lines\": lines,\n            \"sourceModified\": source_modified,\n        },\n    )\n</code></pre>"},{"location":"api-reference/#dap.client.Client.set_data_breakpoints","title":"<code>set_data_breakpoints(breakpoints)</code>","text":"<p>Replaces all existing data breakpoints with new data breakpoints.</p> <p>Parameters:</p> Name Type Description Default <code>breakpoints</code> <code>List[DataBreakpoint]</code> <p>The data breakpoints to set.</p> required Source code in <code>src\\dap\\client.py</code> <pre><code>def set_data_breakpoints(self, breakpoints: List[DataBreakpoint]) -&gt; int:\n    \"\"\"Replaces all existing data breakpoints with new data breakpoints.\n\n    Args:\n        breakpoints: The data breakpoints to set.\n    \"\"\"\n\n    return self.send_request(\"setDataBreakpoints\", {\"breakpoints\": breakpoints})\n</code></pre>"},{"location":"api-reference/#dap.client.Client.set_exception_breakpoints","title":"<code>set_exception_breakpoints(filters, filter_options, exception_options)</code>","text":"<p>The request configures the debugger's response to thrown exceptions.</p> <p>Each of the filters, filterOptions, and exceptionOptions in the request are independent configurations to a debug adapter indicating a kind of exception to catch. An exception thrown in a program should result in a stopped event from the debug adapter (with reason exception) if any of the configured filters match.</p> <p>Parameters:</p> Name Type Description Default <code>filters</code> <code>List[str]</code> <p>Set of exception filters specified by their ID.</p> required <code>filter_options</code> <code>Optional[List[ExceptionFilterOptions]]</code> <p>An array of ExceptionFilterOptions. The set of all possible exception filters                 is defined by the <code>exceptionBreakpointFilters</code> capability.</p> required <code>exception_options</code> <code>Optional[List[ExceptionOptions]]</code> <p>An array of ExceptionOptions. Configuration options for selected exceptions.</p> required Source code in <code>src\\dap\\client.py</code> <pre><code>def set_exception_breakpoints(\n    self,\n    filters: List[str],\n    filter_options: Optional[List[ExceptionFilterOptions]],\n    exception_options: Optional[List[ExceptionOptions]],\n) -&gt; int:\n    \"\"\"The request configures the debugger's response to thrown exceptions.\n\n    Each of the filters, filterOptions, and exceptionOptions in the request are independent configurations\n    to a debug adapter indicating a kind of exception to catch. An exception thrown in a program should result\n    in a stopped event from the debug adapter (with reason exception) if any of the configured filters match.\n\n    Args:\n        filters: Set of exception filters specified by their ID.\n        filter_options: An array of ExceptionFilterOptions. The set of all possible exception filters \\\n            is defined by the `exceptionBreakpointFilters` capability.\n        exception_options: An array of ExceptionOptions. Configuration options for selected exceptions.\n    \"\"\"\n\n    return self.send_request(\n        \"setExceptionBreakpoints\",\n        {\n            \"filters\": filters,\n            \"filterOptions\": filter_options,\n            \"exceptionOptions\": exception_options,\n        },\n    )\n</code></pre>"},{"location":"api-reference/#dap.client.Client.set_expression","title":"<code>set_expression(expression, value, frame_id=None, format=None)</code>","text":"<p>Evaluates the given value expression and assigns it to the expression which must be a modifiable l-value.</p> <p>The expressions have access to any variables and arguments that are in scope of the specified frame.</p> <p>Parameters:</p> Name Type Description Default <code>expression</code> <code>str</code> <p>The l-value expression to assign the result to.</p> required <code>value</code> <code>str</code> <p>The value expression to assign to the l-value expression.</p> required <code>frame_id</code> <code>Optional[int]</code> <p>Evaluate the expressions in the scope of this stack frame.                 If not specified, the expressions are evaluated in the global scope.</p> <code>None</code> <code>format</code> <code>Optional[ValueFormat]</code> <p>Specifies details on how to format the result.</p> <code>None</code> Source code in <code>src\\dap\\client.py</code> <pre><code>def set_expression(\n    self,\n    expression: str,\n    value: str,\n    frame_id: Optional[int] = None,\n    format: Optional[ValueFormat] = None,\n) -&gt; int:\n    \"\"\"Evaluates the given value expression and assigns it to the expression which must be a modifiable l-value.\n\n    The expressions have access to any variables and arguments that are in scope of the specified frame.\n\n    Args:\n        expression: The l-value expression to assign the result to.\n        value: The value expression to assign to the l-value expression.\n        frame_id: Evaluate the expressions in the scope of this stack frame. \\\n            If not specified, the expressions are evaluated in the global scope.\n        format: Specifies details on how to format the result.\n    \"\"\"\n\n    return self.send_request(\n        \"setExpression\",\n        {\n            \"expression\": expression,\n            \"value\": value,\n            \"frameId\": frame_id,\n            \"format\": format,\n        },\n    )\n</code></pre>"},{"location":"api-reference/#dap.client.Client.set_function_breakpoints","title":"<code>set_function_breakpoints(breakpoints=[])</code>","text":"<p>Replaces all existing function breakpoints with new function breakpoints.</p> <p>To clear all function breakpoints, call this without arguments. When a function breakpoint is hit, a stopped event (with reason function breakpoint) is generated.</p> <p>Parameters:</p> Name Type Description Default <code>breakpoints</code> <code>List[FunctionBreakpoint]</code> <p>The function breakpoints to set.</p> <code>[]</code> Source code in <code>src\\dap\\client.py</code> <pre><code>def set_function_breakpoints(\n    self, breakpoints: List[FunctionBreakpoint] = []\n) -&gt; int:\n    \"\"\"Replaces all existing function breakpoints with new function breakpoints.\n\n    To clear all function breakpoints, call this without arguments.\n    When a function breakpoint is hit, a stopped event (with reason function breakpoint) is generated.\n\n    Args:\n        breakpoints: The function breakpoints to set.\n    \"\"\"\n\n    return self.send_request(\"setFunctionBreakpoints\", {\"breakpoints\": breakpoints})\n</code></pre>"},{"location":"api-reference/#dap.client.Client.set_instruction_breakpoints","title":"<code>set_instruction_breakpoints(breakpoints)</code>","text":"<p>Replaces all existing instruction breakpoints. Typically, instruction breakpoints would be set from a disassembly window.</p> <p>To clear all instruction breakpoints, specify an empty array. When an instruction breakpoint is hit, a stopped event (with reason instruction breakpoint) is generated.</p> <p>Parameters:</p> Name Type Description Default <code>breakpoints</code> <code>List[InstructionBreakpoint]</code> <p>The instruction breakpoints to set.</p> required Source code in <code>src\\dap\\client.py</code> <pre><code>def set_instruction_breakpoints(\n    self, breakpoints: List[InstructionBreakpoint]\n) -&gt; int:\n    \"\"\"Replaces all existing instruction breakpoints. Typically, instruction breakpoints would be set from a disassembly window.\n\n    To clear all instruction breakpoints, specify an empty array.\n    When an instruction breakpoint is hit, a stopped event (with reason instruction breakpoint) is generated.\n\n    Args:\n        breakpoints: The instruction breakpoints to set.\n    \"\"\"\n\n    return self.send_request(\n        \"setInstructionBreakpoints\", {\"breakpoints\": breakpoints}\n    )\n</code></pre>"},{"location":"api-reference/#dap.client.Client.set_variable","title":"<code>set_variable(variables_reference, name, value, format=None)</code>","text":"<p>Set the variable with the given name in the variable container to a new value.</p> <p>Parameters:</p> Name Type Description Default <code>variables_reference</code> <code>int</code> <p>The reference of the variable container.</p> required <code>name</code> <code>str</code> <p>The name of the variable to set.</p> required <code>value</code> <code>str</code> <p>The value to set.</p> required <code>format</code> <code>Optional[ValueFormat]</code> <p>Specifies details on how to format the response value.</p> <code>None</code> Source code in <code>src\\dap\\client.py</code> <pre><code>def set_variable(\n    self,\n    variables_reference: int,\n    name: str,\n    value: str,\n    format: Optional[ValueFormat] = None,\n) -&gt; int:\n    \"\"\"Set the variable with the given name in the variable container to a new value.\n\n    Args:\n        variables_reference: The reference of the variable container.\n        name: The name of the variable to set.\n        value: The value to set.\n        format: Specifies details on how to format the response value.\n    \"\"\"\n\n    return self.send_request(\n        \"setVariable\",\n        {\n            \"variablesReference\": variables_reference,\n            \"name\": name,\n            \"value\": value,\n            \"format\": format,\n        },\n    )\n</code></pre>"},{"location":"api-reference/#dap.client.Client.source","title":"<code>source(source_reference, source=None)</code>","text":"<p>The request retrieves the source code for a given source reference.</p> <p>Parameters:</p> Name Type Description Default <code>source_reference</code> <code>int</code> <p>The reference to the source. This is the same as <code>source.sourceReference</code>.</p> required <code>source</code> <code>Optional[Source]</code> <p>Specifies the source content to load. Either <code>source.path</code> or <code>source.sourceReference</code> must be specified.</p> <code>None</code> Source code in <code>src\\dap\\client.py</code> <pre><code>def source(self, source_reference: int, source: Optional[Source] = None) -&gt; int:\n    \"\"\"The request retrieves the source code for a given source reference.\n\n    Args:\n        source_reference: The reference to the source. This is the same as `source.sourceReference`.\n        source: Specifies the source content to load. Either `source.path` or `source.sourceReference` must be specified.\n    \"\"\"\n\n    return self.send_request(\n        \"source\", {\"sourceReference\": source_reference, \"source\": source}\n    )\n</code></pre>"},{"location":"api-reference/#dap.client.Client.stack_trace","title":"<code>stack_trace(thread_id=None, start_frame=None, levels=None, format=None)</code>","text":"<p>The request returns a stack trace from the current execution state.</p> <p>Request all stack frames by omitting the startFrame and levels arguments.</p> <p>Parameters:</p> Name Type Description Default <code>thread_id</code> <code>Optional[int]</code> <p>Retrieve the stacktrace for this thread.</p> <code>None</code> <code>start_frame</code> <code>Optional[int]</code> <p>The index of the first frame to return; if omitted frames start at 0.</p> <code>None</code> <code>levels</code> <code>Optional[int]</code> <p>The maximum number of frames to return. If levels is not specified or 0, all frames are returned.</p> <code>None</code> <code>format</code> <code>Optional[StackFrameFormat]</code> <p>Specifies details on how to format the stack frames.</p> <code>None</code> Source code in <code>src\\dap\\client.py</code> <pre><code>def stack_trace(\n    self,\n    thread_id: Optional[int] = None,\n    start_frame: Optional[int] = None,\n    levels: Optional[int] = None,\n    format: Optional[StackFrameFormat] = None,\n) -&gt; int:\n    \"\"\"The request returns a stack trace from the current execution state.\n\n    Request all stack frames by omitting the startFrame and levels arguments.\n\n    Args:\n        thread_id: Retrieve the stacktrace for this thread.\n        start_frame: The index of the first frame to return; if omitted frames start at 0.\n        levels: The maximum number of frames to return. If levels is not specified or 0, all frames are returned.\n        format: Specifies details on how to format the stack frames.\n    \"\"\"\n\n    return self.send_request(\n        \"stackTrace\",\n        {\n            \"threadId\": thread_id,\n            \"startFrame\": start_frame,\n            \"levels\": levels,\n            \"format\": format,\n        },\n    )\n</code></pre>"},{"location":"api-reference/#dap.client.Client.step_back","title":"<code>step_back(thread_id, single_thread=None, granularity=None)</code>","text":"<p>The request executes one backward step (in the given granularity) for the specified thread and allows all other threads to run backward freely by resuming them.</p> <p>If the debug adapter supports single thread execution (see capability <code>supportsSingleThreadExecutionRequests</code>), setting the singleThread argument to true prevents other suspended threads from resuming. The debug adapter first sends the response and then a stopped event (with reason step) after the step has completed.</p> <p>Parameters:</p> Name Type Description Default <code>thread_id</code> <code>int</code> <p>ID of the active thread.</p> required <code>single_thread</code> <code>Optional[bool]</code> <p>If true, backward execution is limited to the specified thread.</p> <code>None</code> <code>granularity</code> <code>Optional[SteppingGranularity]</code> <p>The granularity of the step, assumed to be 'statement' if not specified.</p> <code>None</code> Source code in <code>src\\dap\\client.py</code> <pre><code>def step_back(\n    self,\n    thread_id: int,\n    single_thread: Optional[bool] = None,\n    granularity: Optional[SteppingGranularity] = None,\n) -&gt; int:\n    \"\"\"The request executes one backward step (in the given granularity) for the specified thread\n    and allows all other threads to run backward freely by resuming them.\n\n    If the debug adapter supports single thread execution (see capability `supportsSingleThreadExecutionRequests`),\n    setting the singleThread argument to true prevents other suspended threads from resuming.\n    The debug adapter first sends the response and then a stopped event (with reason step) after the step has completed.\n\n    Args:\n        thread_id: ID of the active thread.\n        single_thread: If true, backward execution is limited to the specified thread.\n        granularity: The granularity of the step, assumed to be 'statement' if not specified.\n    \"\"\"\n\n    return self.send_request(\n        \"stepBack\",\n        {\n            \"threadId\": thread_id,\n            \"singleThread\": single_thread,\n            \"granularity\": granularity,\n        },\n    )\n</code></pre>"},{"location":"api-reference/#dap.client.Client.step_in","title":"<code>step_in(thread_id, single_thread=None, target_id=None, granularity=None)</code>","text":"<p>The request resumes the given thread to step into a function/method and allows all other threads to run freely by resuming them.</p> <p>If the debug adapter supports single thread execution (see capability <code>supportsSingleThreadExecutionRequests</code>), setting the singleThread argument to true prevents other suspended threads from resuming.</p> <p>If the request cannot step into a target, stepIn behaves like the next request. The debug adapter first sends the response and then a stopped event (with reason step) after the step has completed.</p> <p>If there are multiple function/method calls (or other targets) on the source line, the argument targetId can be used to control into which target the stepIn should occur.</p> <p>Parameters:</p> Name Type Description Default <code>thread_id</code> <code>int</code> <p>ID of the active thread.</p> required <code>single_thread</code> <code>Optional[bool]</code> <p>If true, stepIn is limited to the specified thread.</p> <code>None</code> <code>target_id</code> <code>Optional[int]</code> <p>The stepIn target for this step.</p> <code>None</code> <code>granularity</code> <code>Optional[SteppingGranularity]</code> <p>The granularity of the step, assumed to be 'statement' if not specified.</p> <code>None</code> Source code in <code>src\\dap\\client.py</code> <pre><code>def step_in(\n    self,\n    thread_id: int,\n    single_thread: Optional[bool] = None,\n    target_id: Optional[int] = None,\n    granularity: Optional[SteppingGranularity] = None,\n) -&gt; int:\n    \"\"\"The request resumes the given thread to step into a function/method and allows all other threads to run freely by resuming them.\n\n    If the debug adapter supports single thread execution (see capability `supportsSingleThreadExecutionRequests`),\n    setting the singleThread argument to true prevents other suspended threads from resuming.\n\n    If the request cannot step into a target, stepIn behaves like the next request.\n    The debug adapter first sends the response and then a stopped event (with reason step) after the step has completed.\n\n    If there are multiple function/method calls (or other targets) on the source line,\n    the argument targetId can be used to control into which target the stepIn should occur.\n\n    Args:\n        thread_id: ID of the active thread.\n        single_thread: If true, stepIn is limited to the specified thread.\n        target_id: The stepIn target for this step.\n        granularity: The granularity of the step, assumed to be 'statement' if not specified.\n    \"\"\"\n\n    return self.send_request(\n        \"stepIn\",\n        {\n            \"threadId\": thread_id,\n            \"singleThread\": single_thread,\n            \"targetId\": target_id,\n            \"granularity\": granularity,\n        },\n    )\n</code></pre>"},{"location":"api-reference/#dap.client.Client.step_in_targets","title":"<code>step_in_targets(frame_id)</code>","text":"<p>The request retrieves the possible stepIn targets for the specified stack frame. These targets can be used in the stepIn request.</p> <p>Parameters:</p> Name Type Description Default <code>frame_id</code> <code>int</code> <p>The stack frame for which to retrieve the possible stepIn targets.</p> required Source code in <code>src\\dap\\client.py</code> <pre><code>def step_in_targets(self, frame_id: int) -&gt; int:\n    \"\"\"The request retrieves the possible stepIn targets for the specified stack frame.\n    These targets can be used in the stepIn request.\n\n    Args:\n        frame_id: The stack frame for which to retrieve the possible stepIn targets.\n    \"\"\"\n\n    return self.send_request(\"stepInTargets\", {\"frameId\": frame_id})\n</code></pre>"},{"location":"api-reference/#dap.client.Client.step_out","title":"<code>step_out(thread_id, single_thread=None, granularity=None)</code>","text":"<p>The request resumes the given thread to step out of the current function/method and allows all other threads to run freely by resuming them.</p> <p>If the debug adapter supports single thread execution (see capability <code>supportsSingleThreadExecutionRequests</code>), setting the singleThread argument to true prevents other suspended threads from resuming.</p> <p>The debug adapter first sends the response and then a stopped event (with reason step) after the step has completed.</p> <p>Parameters:</p> Name Type Description Default <code>thread_id</code> <code>int</code> <p>ID of the active thread.</p> required <code>single_thread</code> <code>Optional[bool]</code> <p>If true, stepOut is limited to the specified thread.</p> <code>None</code> <code>granularity</code> <code>Optional[SteppingGranularity]</code> <p>The granularity of the step, assumed to be 'statement' if not specified.</p> <code>None</code> Source code in <code>src\\dap\\client.py</code> <pre><code>def step_out(\n    self,\n    thread_id: int,\n    single_thread: Optional[bool] = None,\n    granularity: Optional[SteppingGranularity] = None,\n) -&gt; int:\n    \"\"\"The request resumes the given thread to step out of the current function/method and allows all other threads to run freely by resuming them.\n\n    If the debug adapter supports single thread execution (see capability `supportsSingleThreadExecutionRequests`),\n    setting the singleThread argument to true prevents other suspended threads from resuming.\n\n    The debug adapter first sends the response and then a stopped event (with reason step) after the step has completed.\n\n    Args:\n        thread_id: ID of the active thread.\n        single_thread: If true, stepOut is limited to the specified thread.\n        granularity: The granularity of the step, assumed to be 'statement' if not specified.\n    \"\"\"\n\n    return self.send_request(\n        \"stepOut\",\n        {\n            \"threadId\": thread_id,\n            \"singleThread\": single_thread,\n            \"granularity\": granularity,\n        },\n    )\n</code></pre>"},{"location":"api-reference/#dap.client.Client.terminate","title":"<code>terminate(restart=None)</code>","text":"<p>The terminate request is sent from the client to the debug adapter in order to shut down the debuggee gracefully.</p> <p>Typically a debug adapter implements terminate by sending a software signal which the debuggee intercepts in order to clean things up properly before terminating itself.</p> <p>Please note that this request does not directly affect the state of the debug session: if the debuggee decides to veto the graceful shutdown for any reason by not terminating itself, then the debug session just continues.</p> <p>Parameters:</p> Name Type Description Default <code>restart</code> <code>Optional[bool]</code> <p>A value of true indicates that this 'terminate' request is part of a restart sequence.</p> <code>None</code> Source code in <code>src\\dap\\client.py</code> <pre><code>def terminate(self, restart: Optional[bool] = None) -&gt; int:\n    \"\"\"The terminate request is sent from the client to the debug adapter in order to shut down the debuggee gracefully.\n\n    Typically a debug adapter implements terminate by sending a software signal which the debuggee intercepts in order\n    to clean things up properly before terminating itself.\n\n    Please note that this request does not directly affect the state of the debug session: if the debuggee decides to\n    veto the graceful shutdown for any reason by not terminating itself, then the debug session just continues.\n\n    Args:\n        restart: A value of true indicates that this 'terminate' request is part of a restart sequence.\n    \"\"\"\n\n    return self.send_request(\"terminate\", {\"restart\": restart})\n</code></pre>"},{"location":"api-reference/#dap.client.Client.terminate_threads","title":"<code>terminate_threads(thread_ids)</code>","text":"<p>The request terminates the threads with the given ids.</p> <p>Parameters:</p> Name Type Description Default <code>thread_ids</code> <code>List[int]</code> <p>The threads to terminate.</p> required Source code in <code>src\\dap\\client.py</code> <pre><code>def terminate_threads(self, thread_ids: List[int]) -&gt; int:\n    \"\"\"The request terminates the threads with the given ids.\n\n    Args:\n        thread_ids: The threads to terminate.\n    \"\"\"\n\n    return self.send_request(\"terminateThreads\", {\"threadIds\": thread_ids})\n</code></pre>"},{"location":"api-reference/#dap.client.Client.threads","title":"<code>threads()</code>","text":"<p>The request retrieves a list of all threads.</p> Source code in <code>src\\dap\\client.py</code> <pre><code>def threads(self) -&gt; int:\n    \"\"\"The request retrieves a list of all threads.\"\"\"\n\n    return self.send_request(\"threads\")\n</code></pre>"},{"location":"api-reference/#dap.client.Client.variables","title":"<code>variables(variables_reference, filter=None, start=None, count=None, format=None)</code>","text":"<p>Retrieves all child variables for the given variable reference.</p> <p>A filter can be used to limit the fetched children to either named or indexed children.</p> <p>Parameters:</p> Name Type Description Default <code>variables_reference</code> <code>int</code> <p>The variable for which to retrieve its children.</p> required <code>filter</code> <code>Optional[Literal[indexed, named]] | str</code> <p>Filter to limit the child variables to either named or indexed. If not specified, both types are fetched.</p> <code>None</code> <code>start</code> <code>Optional[int]</code> <p>The index of the first variable to return; if omitted variables start at 0.</p> <code>None</code> <code>count</code> <code>Optional[int]</code> <p>The number of variables to return. If not passed or 0, all variables are returned.</p> <code>None</code> <code>format</code> <code>Optional[ValueFormat]</code> <p>Specifies details on how to format the response value.</p> <code>None</code> Source code in <code>src\\dap\\client.py</code> <pre><code>def variables(\n    self,\n    variables_reference: int,\n    filter: Optional[Literal[\"indexed\", \"named\"]] | str = None,\n    start: Optional[int] = None,\n    count: Optional[int] = None,\n    format: Optional[ValueFormat] = None,\n) -&gt; int:\n    \"\"\"Retrieves all child variables for the given variable reference.\n\n    A filter can be used to limit the fetched children to either named or indexed children.\n\n    Args:\n        variables_reference: The variable for which to retrieve its children.\n        filter: Filter to limit the child variables to either named or indexed. If not specified, both types are fetched.\n        start: The index of the first variable to return; if omitted variables start at 0.\n        count: The number of variables to return. If not passed or 0, all variables are returned.\n        format: Specifies details on how to format the response value.\n    \"\"\"\n\n    return self.send_request(\n        \"variables\",\n        {\n            \"variablesReference\": variables_reference,\n            \"filter\": filter,\n            \"start\": start,\n            \"count\": count,\n            \"format\": format,\n        },\n    )\n</code></pre>"},{"location":"api-reference/#dap.client.Client.write_memory","title":"<code>write_memory(memory_reference, data, offset=None, allow_partial=None)</code>","text":"<p>Writes bytes to memory at the provided location.</p> <p>Parameters:</p> Name Type Description Default <code>memory_reference</code> <code>str</code> <p>The memory reference to the base location to write memory.</p> required <code>data</code> <code>str</code> <p>Bytes to write, encoded using base64.</p> required <code>offset</code> <code>Optional[int]</code> <p>The offset (in bytes) of the first byte to write. Can be negative.</p> <code>None</code> <code>allow_partial</code> <code>Optional[bool]</code> <p>Property to control partial writes. If true, the debug adapter should                 attempt to write memory even if the entire memory region is not writable.</p> <code>None</code> Source code in <code>src\\dap\\client.py</code> <pre><code>def write_memory(\n    self,\n    memory_reference: str,\n    data: str,\n    offset: Optional[int] = None,\n    allow_partial: Optional[bool] = None,\n) -&gt; int:\n    \"\"\"Writes bytes to memory at the provided location.\n\n    Args:\n        memory_reference: The memory reference to the base location to write memory.\n        data: Bytes to write, encoded using base64.\n        offset: The offset (in bytes) of the first byte to write. Can be negative.\n        allow_partial: Property to control partial writes. If true, the debug adapter should \\\n            attempt to write memory even if the entire memory region is not writable.\n    \"\"\"\n\n    return self.send_request(\n        \"writeMemory\",\n        {\n            \"memoryReference\": memory_reference,\n            \"offset\": offset,\n            \"data\": data,\n            \"allowPartial\": allow_partial,\n        },\n    )\n</code></pre>"},{"location":"api-reference/#responses","title":"Responses","text":""},{"location":"api-reference/#dap.responses.Attached","title":"<code>Attached</code>","text":"<p>               Bases: <code>Response</code></p> <p>Response to 'attach' request.</p> Source code in <code>src\\dap\\responses.py</code> <pre><code>class Attached(Response):\n    \"\"\"Response to 'attach' request.\"\"\"\n\n    ...\n</code></pre>"},{"location":"api-reference/#dap.responses.BreakpointLocationsResponse","title":"<code>BreakpointLocationsResponse</code>","text":"<p>               Bases: <code>ResponseBody</code></p> <p>Body of a 'breakpointLocations' response.</p> Source code in <code>src\\dap\\responses.py</code> <pre><code>class BreakpointLocationsResponse(ResponseBody):\n    \"\"\"Body of a 'breakpointLocations' response.\"\"\"\n\n    breakpoints: list[BreakpointLocation] = Field(\n        ..., description=\"List of breakpoints.\"\n    )\n</code></pre>"},{"location":"api-reference/#dap.responses.Cancelled","title":"<code>Cancelled</code>","text":"<p>               Bases: <code>Response</code></p> <p>Response to 'cancel' request.</p> Source code in <code>src\\dap\\responses.py</code> <pre><code>class Cancelled(Response):\n    \"\"\"Response to 'cancel' request.\"\"\"\n\n    ...\n</code></pre>"},{"location":"api-reference/#dap.responses.CompletionsResponse","title":"<code>CompletionsResponse</code>","text":"<p>               Bases: <code>ResponseBody</code></p> <p>Body of a 'completions' response.</p> Source code in <code>src\\dap\\responses.py</code> <pre><code>class CompletionsResponse(ResponseBody):\n    \"\"\"Body of a 'completions' response.\"\"\"\n\n    targets: list[CompletionItem] = Field(..., description=\"List of completion items.\")\n</code></pre>"},{"location":"api-reference/#dap.responses.ConfigurationDone","title":"<code>ConfigurationDone</code>","text":"<p>               Bases: <code>Response</code></p> <p>Response to 'configurationDone' request.</p> Source code in <code>src\\dap\\responses.py</code> <pre><code>class ConfigurationDone(Response):\n    \"\"\"Response to 'configurationDone' request.\"\"\"\n\n    ...\n</code></pre>"},{"location":"api-reference/#dap.responses.Continued","title":"<code>Continued</code>","text":"<p>               Bases: <code>ResponseBody</code></p> <p>Body of a 'continue' response.</p> Source code in <code>src\\dap\\responses.py</code> <pre><code>class Continued(ResponseBody):\n    \"\"\"Body of a 'continue' response.\"\"\"\n\n    allThreadsContinued: Optional[bool] = Field(\n        None, description=\"If all threads were continued.\"\n    )\n</code></pre>"},{"location":"api-reference/#dap.responses.DataBreakpointInfoResponse","title":"<code>DataBreakpointInfoResponse</code>","text":"<p>               Bases: <code>ResponseBody</code></p> <p>Body of a 'dataBreakpoint' response.</p> Source code in <code>src\\dap\\responses.py</code> <pre><code>class DataBreakpointInfoResponse(ResponseBody):\n    \"\"\"Body of a 'dataBreakpoint' response.\"\"\"\n\n    dataId: Optional[str] = Field(\n        None, description=\"An identifier for the data breakpoint.\"\n    )\n    description: str = Field(\n        ..., description=\"A user-visible description of the breakpoint.\"\n    )\n    accessTypes: Optional[list[DataBreakpointAccessType]] = Field(\n        None, description=\"The access types of the data breakpoint.\"\n    )\n    canPersist: Optional[bool] = Field(\n        None, description=\"Whether the data breakpoint can be persisted.\"\n    )\n</code></pre>"},{"location":"api-reference/#dap.responses.DisassembleResponse","title":"<code>DisassembleResponse</code>","text":"<p>               Bases: <code>ResponseBody</code></p> <p>Body of a 'disassemble' response.</p> Source code in <code>src\\dap\\responses.py</code> <pre><code>class DisassembleResponse(ResponseBody):\n    \"\"\"Body of a 'disassemble' response.\"\"\"\n\n    instructions: list[DisassembledInstruction] = Field(\n        ..., description=\"List of disassembled instructions.\"\n    )\n</code></pre>"},{"location":"api-reference/#dap.responses.Disconnected","title":"<code>Disconnected</code>","text":"<p>               Bases: <code>Response</code></p> <p>Response to 'disconnect' request.</p> Source code in <code>src\\dap\\responses.py</code> <pre><code>class Disconnected(Response):\n    \"\"\"Response to 'disconnect' request.\"\"\"\n\n    ...\n</code></pre>"},{"location":"api-reference/#dap.responses.EvaluateResponse","title":"<code>EvaluateResponse</code>","text":"<p>               Bases: <code>ResponseBody</code></p> <p>Body of an 'evaluate' response.</p> Source code in <code>src\\dap\\responses.py</code> <pre><code>class EvaluateResponse(ResponseBody):\n    \"\"\"Body of an 'evaluate' response.\"\"\"\n\n    result: str = Field(..., description=\"The result of the evaluation.\")\n    type: Optional[str] = Field(None, description=\"The type of the result.\")\n    presentationHint: Optional[VariablePresentationHint] = Field(\n        None, description=\"The presentation hint of the result.\"\n    )\n    variablesReference: int = Field(\n        ...,\n        description=\"The reference to the variables of the evaluation result.\",\n    )\n    namedVariables: Optional[int] = Field(\n        None, description=\"The number of named variables.\"\n    )\n    indexedVariables: Optional[int] = Field(\n        None, description=\"The number of indexed variables.\"\n    )\n    memoryReference: Optional[str] = Field(\n        None, description=\"The memory reference of the result.\"\n    )\n</code></pre>"},{"location":"api-reference/#dap.responses.GotoDone","title":"<code>GotoDone</code>","text":"<p>               Bases: <code>Response</code></p> <p>Response to 'goto' request.</p> Source code in <code>src\\dap\\responses.py</code> <pre><code>class GotoDone(Response):\n    \"\"\"Response to 'goto' request.\"\"\"\n\n    ...\n</code></pre>"},{"location":"api-reference/#dap.responses.GotoTargetsResponse","title":"<code>GotoTargetsResponse</code>","text":"<p>               Bases: <code>ResponseBody</code></p> <p>Body of a 'gotoTargets' response.</p> Source code in <code>src\\dap\\responses.py</code> <pre><code>class GotoTargetsResponse(ResponseBody):\n    \"\"\"Body of a 'gotoTargets' response.\"\"\"\n\n    targets: list[GotoTarget] = Field(..., description=\"List of goto targets.\")\n</code></pre>"},{"location":"api-reference/#dap.responses.Initialized","title":"<code>Initialized</code>","text":"<p>               Bases: <code>Capabilities</code></p> <p>Response to 'initialize' request.</p> Source code in <code>src\\dap\\responses.py</code> <pre><code>class Initialized(Capabilities):\n    \"\"\"Response to 'initialize' request.\"\"\"\n\n    ...\n</code></pre>"},{"location":"api-reference/#dap.responses.LaunchDone","title":"<code>LaunchDone</code>","text":"<p>               Bases: <code>Response</code></p> <p>Response to 'launch' request.</p> Source code in <code>src\\dap\\responses.py</code> <pre><code>class LaunchDone(Response):\n    \"\"\"Response to 'launch' request.\"\"\"\n\n    ...\n</code></pre>"},{"location":"api-reference/#dap.responses.LoadedSourcesResponse","title":"<code>LoadedSourcesResponse</code>","text":"<p>               Bases: <code>ResponseBody</code></p> <p>Body of a 'loadedSources' response.</p> Source code in <code>src\\dap\\responses.py</code> <pre><code>class LoadedSourcesResponse(ResponseBody):\n    \"\"\"Body of a 'loadedSources' response.\"\"\"\n\n    sources: list[Source] = Field(..., description=\"List of loaded sources.\")\n</code></pre>"},{"location":"api-reference/#dap.responses.ModulesResponse","title":"<code>ModulesResponse</code>","text":"<p>               Bases: <code>ResponseBody</code></p> <p>Body of a 'modules' response.</p> Source code in <code>src\\dap\\responses.py</code> <pre><code>class ModulesResponse(ResponseBody):\n    \"\"\"Body of a 'modules' response.\"\"\"\n\n    modules: list[Module] = Field(..., description=\"List of modules.\")\n    totalModules: Optional[int] = Field(\n        None, description=\"The total number of modules.\"\n    )\n</code></pre>"},{"location":"api-reference/#dap.responses.NextResponse","title":"<code>NextResponse</code>","text":"<p>               Bases: <code>Response</code></p> <p>Response to 'next' request.</p> Source code in <code>src\\dap\\responses.py</code> <pre><code>class NextResponse(Response):\n    \"\"\"Response to 'next' request.\"\"\"\n\n    ...\n</code></pre>"},{"location":"api-reference/#dap.responses.Paused","title":"<code>Paused</code>","text":"<p>               Bases: <code>Response</code></p> <p>Response to 'pause' request.</p> Source code in <code>src\\dap\\responses.py</code> <pre><code>class Paused(Response):\n    \"\"\"Response to 'pause' request.\"\"\"\n\n    ...\n</code></pre>"},{"location":"api-reference/#dap.responses.ReadMemoryResponse","title":"<code>ReadMemoryResponse</code>","text":"<p>               Bases: <code>ResponseBody</code></p> <p>Body of a 'readMemory' response.</p> Source code in <code>src\\dap\\responses.py</code> <pre><code>class ReadMemoryResponse(ResponseBody):\n    \"\"\"Body of a 'readMemory' response.\"\"\"\n\n    address: str = Field(..., description=\"The address of the memory read.\")\n    unreadableBytes: Optional[int] = Field(\n        None, description=\"The number of unreadable bytes.\"\n    )\n    data: Optional[str] = Field(None, description=\"The data read from memory.\")\n</code></pre>"},{"location":"api-reference/#dap.responses.RestartFrameDone","title":"<code>RestartFrameDone</code>","text":"<p>               Bases: <code>Response</code></p> <p>Response to 'restartFrame' request.</p> Source code in <code>src\\dap\\responses.py</code> <pre><code>class RestartFrameDone(Response):\n    \"\"\"Response to 'restartFrame' request.\"\"\"\n\n    ...\n</code></pre>"},{"location":"api-reference/#dap.responses.Restarted","title":"<code>Restarted</code>","text":"<p>               Bases: <code>Response</code></p> <p>Response to 'restart' request.</p> Source code in <code>src\\dap\\responses.py</code> <pre><code>class Restarted(Response):\n    \"\"\"Response to 'restart' request.\"\"\"\n\n    ...\n</code></pre>"},{"location":"api-reference/#dap.responses.ReverseContinueDone","title":"<code>ReverseContinueDone</code>","text":"<p>               Bases: <code>Response</code></p> <p>Response to 'reverseContinue' request.</p> Source code in <code>src\\dap\\responses.py</code> <pre><code>class ReverseContinueDone(Response):\n    \"\"\"Response to 'reverseContinue' request.\"\"\"\n\n    ...\n</code></pre>"},{"location":"api-reference/#dap.responses.RunInTerminalResponse","title":"<code>RunInTerminalResponse</code>","text":"<p>               Bases: <code>Response</code></p> <p>Response to 'runInTerminal' request.</p> Source code in <code>src\\dap\\responses.py</code> <pre><code>class RunInTerminalResponse(Response):\n    \"\"\"Response to 'runInTerminal' request.\"\"\"\n\n    request_seq: int = Field(\n        ..., description=\"Sequence number of the corresponding request.\"\n    )\n    success: bool = Field(\n        ..., description=\"Indicates whether the request was successful.\"\n    )\n    command: str = \"runInTerminal\"\n    body: RunInTerminalResponseBody\n</code></pre>"},{"location":"api-reference/#dap.responses.RunInTerminalResponseBody","title":"<code>RunInTerminalResponseBody</code>","text":"<p>               Bases: <code>ResponseBody</code></p> <p>Body of a 'runInTerminal' response.</p> Source code in <code>src\\dap\\responses.py</code> <pre><code>class RunInTerminalResponseBody(ResponseBody):\n    \"\"\"Body of a 'runInTerminal' response.\"\"\"\n\n    processId: Optional[int] = Field(\n        None, description=\"The process ID of the terminal.\"\n    )\n    shellProcessId: Optional[int] = Field(\n        None, description=\"The process ID of the shell.\"\n    )\n</code></pre>"},{"location":"api-reference/#dap.responses.ScopesResponse","title":"<code>ScopesResponse</code>","text":"<p>               Bases: <code>ResponseBody</code></p> <p>Body of a 'scopes' response.</p> Source code in <code>src\\dap\\responses.py</code> <pre><code>class ScopesResponse(ResponseBody):\n    \"\"\"Body of a 'scopes' response.\"\"\"\n\n    scopes: list[Scope] = Field(..., description=\"List of scopes.\")\n</code></pre>"},{"location":"api-reference/#dap.responses.SetBreakpointsResponse","title":"<code>SetBreakpointsResponse</code>","text":"<p>               Bases: <code>ResponseBody</code></p> <p>Body of a 'setBreakpoints' response.</p> Source code in <code>src\\dap\\responses.py</code> <pre><code>class SetBreakpointsResponse(ResponseBody):\n    \"\"\"Body of a 'setBreakpoints' response.\"\"\"\n\n    breakpoints: list[Breakpoint]\n</code></pre>"},{"location":"api-reference/#dap.responses.SetDataBreakpointsResponse","title":"<code>SetDataBreakpointsResponse</code>","text":"<p>               Bases: <code>ResponseBody</code></p> <p>Body of a 'setDataBreakpoints' response.</p> Source code in <code>src\\dap\\responses.py</code> <pre><code>class SetDataBreakpointsResponse(ResponseBody):\n    \"\"\"Body of a 'setDataBreakpoints' response.\"\"\"\n\n    breakpoints: list[Breakpoint]\n</code></pre>"},{"location":"api-reference/#dap.responses.SetExceptionBreakpointsResponse","title":"<code>SetExceptionBreakpointsResponse</code>","text":"<p>               Bases: <code>Response</code></p> <p>Response to 'setExceptionBreakpoints' request.</p> Source code in <code>src\\dap\\responses.py</code> <pre><code>class SetExceptionBreakpointsResponse(Response):\n    \"\"\"Response to 'setExceptionBreakpoints' request.\"\"\"\n\n    ...\n</code></pre>"},{"location":"api-reference/#dap.responses.SetExpressionResponse","title":"<code>SetExpressionResponse</code>","text":"<p>               Bases: <code>ResponseBody</code></p> <p>Body of a 'setExpression' response.</p> Source code in <code>src\\dap\\responses.py</code> <pre><code>class SetExpressionResponse(ResponseBody):\n    \"\"\"Body of a 'setExpression' response.\"\"\"\n\n    value: str = Field(..., description=\"The value of the expression.\")\n    type: Optional[str] = Field(None, description=\"The type of the expression.\")\n    presentationHint: Optional[VariablePresentationHint] = Field(\n        None, description=\"The presentation hint of the expression.\"\n    )\n    variablesReference: Optional[int] = Field(\n        None,\n        description=\"The reference to the variables of the expression result.\",\n    )\n    namedVariables: Optional[int] = Field(\n        None, description=\"The number of named variables.\"\n    )\n    indexedVariables: Optional[int] = Field(\n        None, description=\"The number of indexed variables.\"\n    )\n    memoryReference: Optional[str] = Field(\n        None, description=\"The memory reference of the expression.\"\n    )\n</code></pre>"},{"location":"api-reference/#dap.responses.SetFunctionBreakpointsResponse","title":"<code>SetFunctionBreakpointsResponse</code>","text":"<p>               Bases: <code>ResponseBody</code></p> <p>Body of a 'setFunctionBreakpoints' response.</p> Source code in <code>src\\dap\\responses.py</code> <pre><code>class SetFunctionBreakpointsResponse(ResponseBody):\n    \"\"\"Body of a 'setFunctionBreakpoints' response.\"\"\"\n\n    breakpoints: list[FunctionBreakpoint] = Field(\n        ..., description=\"List of function breakpoints.\"\n    )\n</code></pre>"},{"location":"api-reference/#dap.responses.SetInstructionBreakpointsResponse","title":"<code>SetInstructionBreakpointsResponse</code>","text":"<p>               Bases: <code>ResponseBody</code></p> <p>Body of a 'setInstructionBreakpoints' response.</p> Source code in <code>src\\dap\\responses.py</code> <pre><code>class SetInstructionBreakpointsResponse(ResponseBody):\n    \"\"\"Body of a 'setInstructionBreakpoints' response.\"\"\"\n\n    breakpoints: list[Breakpoint]\n</code></pre>"},{"location":"api-reference/#dap.responses.SetVariableResponse","title":"<code>SetVariableResponse</code>","text":"<p>               Bases: <code>ResponseBody</code></p> <p>Body of a 'setVariable' response.</p> Source code in <code>src\\dap\\responses.py</code> <pre><code>class SetVariableResponse(ResponseBody):\n    \"\"\"Body of a 'setVariable' response.\"\"\"\n\n    value: str = Field(..., description=\"The value of the variable.\")\n    type: Optional[str] = Field(None, description=\"The type of the variable.\")\n    variablesReference: Optional[int] = Field(\n        None,\n        description=\"The reference to the variables of the variable result.\",\n    )\n    namedVariables: Optional[int] = Field(\n        None, description=\"The number of named variables.\"\n    )\n    indexedVariables: Optional[int] = Field(\n        None, description=\"The number of indexed variables.\"\n    )\n    memoryReference: Optional[str] = Field(\n        None, description=\"The memory reference of the variable.\"\n    )\n</code></pre>"},{"location":"api-reference/#dap.responses.SourceResponse","title":"<code>SourceResponse</code>","text":"<p>               Bases: <code>ResponseBody</code></p> <p>Body of a 'source' response.</p> Source code in <code>src\\dap\\responses.py</code> <pre><code>class SourceResponse(ResponseBody):\n    \"\"\"Body of a 'source' response.\"\"\"\n\n    content: str = Field(..., description=\"The content of the source.\")\n    mimeType: Optional[str] = Field(None, description=\"The MIME type of the source.\")\n</code></pre>"},{"location":"api-reference/#dap.responses.StackTraceResponse","title":"<code>StackTraceResponse</code>","text":"<p>               Bases: <code>ResponseBody</code></p> <p>Body of a 'stackTrace' response.</p> Source code in <code>src\\dap\\responses.py</code> <pre><code>class StackTraceResponse(ResponseBody):\n    \"\"\"Body of a 'stackTrace' response.\"\"\"\n\n    stackFrames: list[StackFrame] = Field(..., description=\"List of stack frames.\")\n    totalFrames: Optional[int] = Field(None, description=\"The total number of frames.\")\n</code></pre>"},{"location":"api-reference/#dap.responses.StartDebuggingResponse","title":"<code>StartDebuggingResponse</code>","text":"<p>               Bases: <code>Response</code></p> <p>Body of a 'startDebugging' response.</p> Source code in <code>src\\dap\\responses.py</code> <pre><code>class StartDebuggingResponse(Response):\n    \"\"\"Body of a 'startDebugging' response.\"\"\"\n\n    request_seq: int = Field(\n        ..., description=\"Sequence number of the corresponding request.\"\n    )\n    success: bool = Field(\n        ..., description=\"Indicates whether the request was successful.\"\n    )\n    command: str = \"startDebugging\"\n</code></pre>"},{"location":"api-reference/#dap.responses.StepBackDone","title":"<code>StepBackDone</code>","text":"<p>               Bases: <code>Response</code></p> <p>Response to 'stepBack' request.</p> Source code in <code>src\\dap\\responses.py</code> <pre><code>class StepBackDone(Response):\n    \"\"\"Response to 'stepBack' request.\"\"\"\n\n    ...\n</code></pre>"},{"location":"api-reference/#dap.responses.StepInDone","title":"<code>StepInDone</code>","text":"<p>               Bases: <code>Response</code></p> <p>Response to 'stepIn' request.</p> Source code in <code>src\\dap\\responses.py</code> <pre><code>class StepInDone(Response):\n    \"\"\"Response to 'stepIn' request.\"\"\"\n\n    ...\n</code></pre>"},{"location":"api-reference/#dap.responses.StepInTargetsResponse","title":"<code>StepInTargetsResponse</code>","text":"<p>               Bases: <code>ResponseBody</code></p> <p>Body of a 'stepInTargets' response.</p> Source code in <code>src\\dap\\responses.py</code> <pre><code>class StepInTargetsResponse(ResponseBody):\n    \"\"\"Body of a 'stepInTargets' response.\"\"\"\n\n    targets: list[StepInTarget] = Field(..., description=\"List of step in targets.\")\n</code></pre>"},{"location":"api-reference/#dap.responses.StepOutDone","title":"<code>StepOutDone</code>","text":"<p>               Bases: <code>Response</code></p> <p>Response to 'stepOut' request.</p> Source code in <code>src\\dap\\responses.py</code> <pre><code>class StepOutDone(Response):\n    \"\"\"Response to 'stepOut' request.\"\"\"\n\n    ...\n</code></pre>"},{"location":"api-reference/#dap.responses.TerminateThreadsDone","title":"<code>TerminateThreadsDone</code>","text":"<p>               Bases: <code>Response</code></p> <p>Response to 'terminateThreads' request.</p> Source code in <code>src\\dap\\responses.py</code> <pre><code>class TerminateThreadsDone(Response):\n    \"\"\"Response to 'terminateThreads' request.\"\"\"\n\n    ...\n</code></pre>"},{"location":"api-reference/#dap.responses.Terminated","title":"<code>Terminated</code>","text":"<p>               Bases: <code>Response</code></p> <p>Response to 'terminate' request.</p> Source code in <code>src\\dap\\responses.py</code> <pre><code>class Terminated(Response):\n    \"\"\"Response to 'terminate' request.\"\"\"\n\n    ...\n</code></pre>"},{"location":"api-reference/#dap.responses.ThreadsResponse","title":"<code>ThreadsResponse</code>","text":"<p>               Bases: <code>ResponseBody</code></p> <p>Body of a 'threads' response.</p> Source code in <code>src\\dap\\responses.py</code> <pre><code>class ThreadsResponse(ResponseBody):\n    \"\"\"Body of a 'threads' response.\"\"\"\n\n    threads: list[Thread] = Field(..., description=\"List of threads.\")\n</code></pre>"},{"location":"api-reference/#dap.responses.VariablesResponse","title":"<code>VariablesResponse</code>","text":"<p>               Bases: <code>ResponseBody</code></p> <p>Body of a 'variables' response.</p> Source code in <code>src\\dap\\responses.py</code> <pre><code>class VariablesResponse(ResponseBody):\n    \"\"\"Body of a 'variables' response.\"\"\"\n\n    variables: list[Variable] = Field(..., description=\"List of variables.\")\n</code></pre>"},{"location":"api-reference/#dap.responses.WriteMemoryResponse","title":"<code>WriteMemoryResponse</code>","text":"<p>               Bases: <code>ResponseBody</code></p> <p>Body of a 'writeMemory' response.</p> Source code in <code>src\\dap\\responses.py</code> <pre><code>class WriteMemoryResponse(ResponseBody):\n    \"\"\"Body of a 'writeMemory' response.\"\"\"\n\n    offset: Optional[int] = Field(None, description=\"The offset of the memory write.\")\n    bytesWritten: Optional[int] = Field(\n        None, description=\"The number of bytes written.\"\n    )\n</code></pre>"},{"location":"api-reference/#events","title":"Events","text":""},{"location":"api-reference/#dap.events.BreakpointEvent","title":"<code>BreakpointEvent</code>","text":"<p>               Bases: <code>EventBody</code></p> <p>Event sent when a breakpoint is hit.</p> Source code in <code>src\\dap\\events.py</code> <pre><code>class BreakpointEvent(EventBody):\n    \"\"\"Event sent when a breakpoint is hit.\"\"\"\n\n    reason: Literal[\"changed\", \"new\", \"removed\"] | str = Field(\n        ...,\n        description=\"The reason the event was sent. 'changed' for a changed breakpoint, 'new' for a new breakpoint, 'removed' for a removed breakpoint.\",\n    )\n    breakpoint: Breakpoint = Field(..., description=\"The breakpoint that was hit.\")\n</code></pre>"},{"location":"api-reference/#dap.events.CapabilitiesEvent","title":"<code>CapabilitiesEvent</code>","text":"<p>               Bases: <code>EventBody</code></p> <p>Event sent when capabilities are requested.</p> Source code in <code>src\\dap\\events.py</code> <pre><code>class CapabilitiesEvent(EventBody):\n    \"\"\"Event sent when capabilities are requested.\"\"\"\n\n    capabilities: Capabilities = Field(\n        ..., description=\"The capabilities of the debug adapter.\"\n    )\n</code></pre>"},{"location":"api-reference/#dap.events.ContinuedEvent","title":"<code>ContinuedEvent</code>","text":"<p>               Bases: <code>EventBody</code></p> <p>Event sent when the execution is continued.</p> Source code in <code>src\\dap\\events.py</code> <pre><code>class ContinuedEvent(EventBody):\n    \"\"\"Event sent when the execution is continued.\"\"\"\n\n    threadId: int = Field(..., description=\"The thread that continued.\")\n    allThreadsContinued: Optional[bool] = Field(\n        None,\n        description=\"If all threads continued, the attribute is omitted. If a specific thread continued, the attribute contains the thread ID.\",\n    )\n</code></pre>"},{"location":"api-reference/#dap.events.ExitedEvent","title":"<code>ExitedEvent</code>","text":"<p>               Bases: <code>EventBody</code></p> <p>Event sent when the debuggee has exited.</p> Source code in <code>src\\dap\\events.py</code> <pre><code>class ExitedEvent(EventBody):\n    \"\"\"Event sent when the debuggee has exited.\"\"\"\n\n    exitCode: int = Field(..., description=\"The exit code of the debuggee.\")\n</code></pre>"},{"location":"api-reference/#dap.events.InitializedEvent","title":"<code>InitializedEvent</code>","text":"<p>               Bases: <code>EventBody</code></p> <p>Event sent when the debug adapter is initialized.</p> Source code in <code>src\\dap\\events.py</code> <pre><code>class InitializedEvent(EventBody):\n    \"\"\"Event sent when the debug adapter is initialized.\"\"\"\n\n    ...\n</code></pre>"},{"location":"api-reference/#dap.events.InvalidatedEvent","title":"<code>InvalidatedEvent</code>","text":"<p>               Bases: <code>EventBody</code></p> <p>Event sent when breakpoints are invalidated.</p> Source code in <code>src\\dap\\events.py</code> <pre><code>class InvalidatedEvent(EventBody):\n    \"\"\"Event sent when breakpoints are invalidated.\"\"\"\n\n    areas: Optional[list[InvalidatedAreas]] = Field(\n        None, description=\"The invalidated areas.\"\n    )\n    threadId: Optional[int] = Field(\n        None,\n        description=\"The thread ID of the invalidated areas. If omitted, the invalidated areas are not specific to a thread.\",\n    )\n    stackFrameId: Optional[int] = Field(\n        None,\n        description=\"The stack frame ID of the invalidated areas. If omitted, the invalidated areas are not specific to a stack frame.\",\n    )\n</code></pre>"},{"location":"api-reference/#dap.events.LoadedSourceEvent","title":"<code>LoadedSourceEvent</code>","text":"<p>               Bases: <code>EventBody</code></p> <p>Event sent when a source is loaded.</p> Source code in <code>src\\dap\\events.py</code> <pre><code>class LoadedSourceEvent(EventBody):\n    \"\"\"Event sent when a source is loaded.\"\"\"\n\n    reason: Literal[\"new\", \"changed\", \"removed\"] = Field(\n        ...,\n        description=\"The reason the event was sent. 'new' for a new source, 'changed' for a changed source, 'removed' for a removed source.\",\n    )\n    source: Source = Field(..., description=\"The source that was loaded.\")\n</code></pre>"},{"location":"api-reference/#dap.events.MemoryEvent","title":"<code>MemoryEvent</code>","text":"<p>               Bases: <code>EventBody</code></p> <p>Event sent when memory is accessed.</p> Source code in <code>src\\dap\\events.py</code> <pre><code>class MemoryEvent(EventBody):\n    \"\"\"Event sent when memory is accessed.\"\"\"\n\n    memoryReference: str = Field(..., description=\"The memory reference.\")\n    offset: int = Field(..., description=\"The memory offset.\")\n    count: int = Field(..., description=\"The number of bytes.\")\n</code></pre>"},{"location":"api-reference/#dap.events.ModuleEvent","title":"<code>ModuleEvent</code>","text":"<p>               Bases: <code>EventBody</code></p> <p>Event sent when a module is loaded or unloaded.</p> Source code in <code>src\\dap\\events.py</code> <pre><code>class ModuleEvent(EventBody):\n    \"\"\"Event sent when a module is loaded or unloaded.\"\"\"\n\n    reason: Literal[\"new\", \"changed\", \"removed\"] = Field(\n        ...,\n        description=\"The reason the event was sent. 'new' for a new module, 'changed' for a changed module, 'removed' for a removed module.\",\n    )\n    module: Module = Field(..., description=\"The module that was loaded or unloaded.\")\n</code></pre>"},{"location":"api-reference/#dap.events.OutputEvent","title":"<code>OutputEvent</code>","text":"<p>               Bases: <code>EventBody</code></p> <p>Event sent when output is produced.</p> Source code in <code>src\\dap\\events.py</code> <pre><code>class OutputEvent(EventBody):\n    \"\"\"Event sent when output is produced.\"\"\"\n\n    category: Optional[\n        Literal[\"console\", \"important\", \"stdout\", \"stderr\", \"telemetry\"] | str\n    ] = Field(\n        ...,\n        description=\"The category of the output.\",\n    )\n    output: str = Field(..., description=\"The output text.\")\n    group: Optional[Literal[\"start\", \"startCollapsed\", \"end\"]] = Field(\n        None,\n        description=\"The output group.\",\n    )\n    variablesReference: Optional[int] = Field(\n        None,\n        description=\"The reference to a variable.\",\n    )\n    source: Optional[Source] = Field(\n        None,\n        description=\"The source of the output.\",\n    )\n    line: Optional[int] = Field(\n        None,\n        description=\"The line of the output.\",\n    )\n    column: Optional[int] = Field(\n        None,\n        description=\"The column of the output.\",\n    )\n    data: Optional[Any] = Field(None, description=\"Additional data.\")\n</code></pre>"},{"location":"api-reference/#dap.events.ProcessEvent","title":"<code>ProcessEvent</code>","text":"<p>               Bases: <code>EventBody</code></p> <p>Event sent when a process is created or exited.</p> Source code in <code>src\\dap\\events.py</code> <pre><code>class ProcessEvent(EventBody):\n    \"\"\"Event sent when a process is created or exited.\"\"\"\n\n    name: str = Field(..., description=\"The name of the process.\")\n    systemProcessId: Optional[int] = Field(\n        None,\n        description=\"The system process ID.\",\n    )\n    isLocalProcess: Optional[bool] = Field(\n        None,\n        description=\"If the process is local.\",\n    )\n    startMethod: Optional[Literal[\"launch\", \"attach\", \"attachForSuspendedLaunch\"]] = (\n        Field(\n            None,\n            description=\"The start method.\",\n        )\n    )\n    pointerSize: Optional[int] = Field(\n        None,\n        description=\"The pointer size.\",\n    )\n</code></pre>"},{"location":"api-reference/#dap.events.ProgressEndEvent","title":"<code>ProgressEndEvent</code>","text":"<p>               Bases: <code>EventBody</code></p> <p>Event sent when a progress ends.</p> Source code in <code>src\\dap\\events.py</code> <pre><code>class ProgressEndEvent(EventBody):\n    \"\"\"Event sent when a progress ends.\"\"\"\n\n    progressId: str = Field(..., description=\"The progress ID.\")\n    message: Optional[str] = Field(None, description=\"The message.\")\n</code></pre>"},{"location":"api-reference/#dap.events.ProgressStartEvent","title":"<code>ProgressStartEvent</code>","text":"<p>               Bases: <code>EventBody</code></p> <p>Event sent when a progress starts.</p> Source code in <code>src\\dap\\events.py</code> <pre><code>class ProgressStartEvent(EventBody):\n    \"\"\"Event sent when a progress starts.\"\"\"\n\n    progressId: str = Field(..., description=\"The progress ID.\")\n    title: str = Field(..., description=\"The title of the progress.\")\n    requestId: Optional[str] = Field(\n        None,\n        description=\"The request ID.\",\n    )\n    cancellable: Optional[bool] = Field(\n        None,\n        description=\"If the progress is cancellable.\",\n    )\n    message: Optional[str] = Field(None, description=\"The message.\")\n    percentage: Optional[int] = Field(\n        None,\n        description=\"The percentage of the progress.\",\n    )\n</code></pre>"},{"location":"api-reference/#dap.events.ProgressUpdateEvent","title":"<code>ProgressUpdateEvent</code>","text":"<p>               Bases: <code>EventBody</code></p> <p>Event sent when a progress updates.</p> Source code in <code>src\\dap\\events.py</code> <pre><code>class ProgressUpdateEvent(EventBody):\n    \"\"\"Event sent when a progress updates.\"\"\"\n\n    progressId: str = Field(..., description=\"The progress ID.\")\n    message: Optional[str] = Field(None, description=\"The message.\")\n    percentage: Optional[int] = Field(\n        None,\n        description=\"The percentage of the progress.\",\n    )\n</code></pre>"},{"location":"api-reference/#dap.events.StoppedEvent","title":"<code>StoppedEvent</code>","text":"<p>               Bases: <code>EventBody</code></p> <p>Event sent when the execution is stopped.</p> Source code in <code>src\\dap\\events.py</code> <pre><code>class StoppedEvent(EventBody):\n    \"\"\"Event sent when the execution is stopped.\"\"\"\n\n    reason: Literal[\n        \"step\",\n        \"breakpoint\",\n        \"exception\",\n        \"pause\",\n        \"entry\",\n        \"goto\",\n        \"function breakpoint\",\n        \"data breakpoint\",\n        \"instruction breakpoint\",\n    ] = Field(\n        ...,\n        description=\"The reason the execution was stopped.\",\n    )\n    description: Optional[str] = Field(\n        None,\n        description=\"The description of the stop event.\",\n    )\n    threadId: Optional[int] = Field(\n        None,\n        description=\"The thread that stopped.\",\n    )\n    preserveFocusHint: Optional[bool] = Field(\n        None,\n        description=\"If the focus should be preserved.\",\n    )\n    text: Optional[str] = Field(\n        None,\n        description=\"The text of the stop event.\",\n    )\n    allThreadsStopped: Optional[bool] = Field(\n        None,\n        description=\"If all threads stopped, the attribute is omitted. If a specific thread stopped, the attribute contains the thread ID.\",\n    )\n    hitBreakpointIds: Optional[list[str]] = Field(\n        None,\n        description=\"The hit breakpoint IDs.\",\n    )\n</code></pre>"},{"location":"api-reference/#dap.events.TerminatedEvent","title":"<code>TerminatedEvent</code>","text":"<p>               Bases: <code>EventBody</code></p> <p>Event sent when the debuggee is terminated.</p> Source code in <code>src\\dap\\events.py</code> <pre><code>class TerminatedEvent(EventBody):\n    \"\"\"Event sent when the debuggee is terminated.\"\"\"\n\n    restart: Optional[bool] = Field(\n        None,\n        description=\"If the debuggee should be restarted.\",\n    )\n</code></pre>"},{"location":"api-reference/#dap.events.ThreadEvent","title":"<code>ThreadEvent</code>","text":"<p>               Bases: <code>EventBody</code></p> <p>Event sent when a thread is created or exited.</p> Source code in <code>src\\dap\\events.py</code> <pre><code>class ThreadEvent(EventBody):\n    \"\"\"Event sent when a thread is created or exited.\"\"\"\n\n    reason: Literal[\"started\", \"exited\"] | str = Field(\n        ...,\n        description=\"The reason the event was sent. 'started' for a started thread, 'exited' for an exited thread.\",\n    )\n    threadId: int = Field(..., description=\"The thread ID.\")\n</code></pre>"},{"location":"api-reference/#requests","title":"Requests","text":""},{"location":"api-reference/#dap.requests.AttachRequestArguments","title":"<code>AttachRequestArguments</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Arguments for 'attach' request.</p> Source code in <code>src\\dap\\requests.py</code> <pre><code>class AttachRequestArguments(TypedDict):\n    \"\"\"Arguments for 'attach' request.\"\"\"\n\n    __restart: Optional[bool] = None\n</code></pre>"},{"location":"api-reference/#dap.requests.LaunchRequestArguments","title":"<code>LaunchRequestArguments</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Arguments for 'launch' request.</p> Source code in <code>src\\dap\\requests.py</code> <pre><code>class LaunchRequestArguments(TypedDict):\n    \"\"\"Arguments for 'launch' request.\"\"\"\n\n    noDebug: Optional[bool] = None\n    __restart: Optional[bool] = None\n</code></pre>"},{"location":"api-reference/#dap.requests.RunInTerminalRequest","title":"<code>RunInTerminalRequest</code>","text":"<p>               Bases: <code>Request</code></p> <p>Request for 'runInTerminal' reverse request.</p> Source code in <code>src\\dap\\requests.py</code> <pre><code>class RunInTerminalRequest(Request):\n    \"\"\"Request for 'runInTerminal' reverse request.\"\"\"\n\n    command: Literal[\"runInTerminal\"] = \"runInTerminal\"\n    arguments: RunInTerminalRequestArguments\n\n    def reply(\n        self,\n        success: bool,\n        processId: Optional[int] = None,\n        shellProcessId: Optional[int] = None,\n    ) -&gt; RunInTerminalResponse:\n        return RunInTerminalResponse(\n            seq=self.seq,\n            request_seq=self.seq,\n            success=success,\n            body=RunInTerminalResponseBody(\n                processId=processId,\n                shellProcessId=shellProcessId,\n            ),\n        )\n</code></pre>"},{"location":"api-reference/#dap.requests.RunInTerminalRequestArguments","title":"<code>RunInTerminalRequestArguments</code>","text":"<p>               Bases: <code>RequestArguments</code></p> <p>Arguments for 'runInTerminal' reverse request.</p> Source code in <code>src\\dap\\requests.py</code> <pre><code>class RunInTerminalRequestArguments(RequestArguments):\n    \"\"\"Arguments for 'runInTerminal' reverse request.\"\"\"\n\n    kind: Optional[str] = Field(\n        None,\n        description=\"The kind of terminal to run the command in.\",\n    )\n    title: Optional[str] = Field(\n        None,\n        description=\"The title of the terminal.\",\n    )\n    cwd: str = Field(\n        ...,\n        description=\"The working directory of the terminal.\",\n    )\n    args: list[str] = Field(\n        ...,\n        description=\"The command to run in the terminal.\",\n    )\n    env: Optional[dict[str, str | None]] = Field(\n        None,\n        description=\"Environment key-value pairs that should be added to or removed from the default environment.\",\n    )\n    argsCanBeInterpretedByShell: Optional[bool] = Field(\n        None,\n        description=\"Whether the arguments can be interpreted as shell commands.\",\n    )\n</code></pre>"},{"location":"api-reference/#dap.requests.StartDebuggingRequest","title":"<code>StartDebuggingRequest</code>","text":"<p>               Bases: <code>Request</code></p> <p>Request for 'startDebugging' request.</p> Source code in <code>src\\dap\\requests.py</code> <pre><code>class StartDebuggingRequest(Request):\n    \"\"\"Request for 'startDebugging' request.\"\"\"\n\n    command: Literal[\"startDebugging\"] = \"startDebugging\"\n    arguments: StartDebuggingRequestArguments\n\n    def reply(self, success: bool) -&gt; StartDebuggingResponse:\n        return StartDebuggingResponse(\n            seq=self.seq,\n            request_seq=self.seq,\n            success=success,\n        )\n</code></pre>"},{"location":"api-reference/#dap.requests.StartDebuggingRequestArguments","title":"<code>StartDebuggingRequestArguments</code>","text":"<p>               Bases: <code>RequestArguments</code></p> <p>Arguments for 'startDebugging' request.</p> Source code in <code>src\\dap\\requests.py</code> <pre><code>class StartDebuggingRequestArguments(RequestArguments):\n    \"\"\"Arguments for 'startDebugging' request.\"\"\"\n\n    configuration: dict[str, str] = Field(\n        ...,\n        description=\"Arguments passed to the new debug session. The arguments must only contain properties understood by \"\n        \"the `launch` or `attach` requests of the debug adapter and they must not contain any client-specific properties \"\n        \"(e.g. `type`) or client-specific features (e.g. substitutable 'variables')\",\n    )\n    request: Literal[\"launch\", \"attach\"] = Field(\n        ...,\n        description=\"The request type: 'launch' or 'attach'.\",\n    )\n</code></pre>"},{"location":"api-reference/#base-protocol","title":"Base Protocol","text":""},{"location":"api-reference/#dap.base.EventBody","title":"<code>EventBody</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base class of event bodies</p> Source code in <code>src\\dap\\base.py</code> <pre><code>class EventBody(BaseModel):\n    \"\"\"Base class of event bodies\"\"\"\n\n    ...\n</code></pre>"},{"location":"api-reference/#dap.base.Events","title":"<code>Events</code>","text":"<p>               Bases: <code>StrEnum</code></p> <p>Enumeration of DAP events.</p> Source code in <code>src\\dap\\base.py</code> <pre><code>class Events(StrEnum):\n    \"\"\"Enumeration of DAP events.\"\"\"\n\n    BREAKPOINT = \"breakpoint\"\n    CAPABILITIES = \"capabilities\"\n    CONTINUED = \"continued\"\n    EXITED = \"exited\"\n    INITIALIZED = \"initialized\"\n    INVALIDATED = \"invalidated\"\n    LOADED_SOURCE = \"loadedSource\"\n    MEMORY = \"memory\"\n    MODULE = \"module\"\n    OUTPUT = \"output\"\n    PROCESS = \"process\"\n    PROGRESS_END = \"progressEnd\"\n    PROGRESS_START = \"progressStart\"\n    PROGRESS_UPDATE = \"progressUpdate\"\n    STOPPED = \"stopped\"\n    TERMINATED = \"terminated\"\n    THREAD = \"thread\"\n</code></pre>"},{"location":"api-reference/#dap.base.ProtocolMessage","title":"<code>ProtocolMessage</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base class of requests, responses, and events</p> Source code in <code>src\\dap\\base.py</code> <pre><code>class ProtocolMessage(BaseModel):\n    \"\"\"Base class of requests, responses, and events\"\"\"\n\n    seq: int = Field(..., description=\"Sequence number (message ID) of the message.\")\n    type: Literal[\"request\", \"response\", \"event\"] | str = Field(\n        ..., description=\"Message type.\"\n    )\n</code></pre>"},{"location":"api-reference/#dap.base.Request","title":"<code>Request</code>","text":"<p>               Bases: <code>ProtocolMessage</code></p> Source code in <code>src\\dap\\base.py</code> <pre><code>class Request(ProtocolMessage):\n    type: str = \"request\"  # type: ignore\n    command: str = Field(..., description=\"The command to execute.\")\n    arguments: Optional[Any] = Field(\n        None, description=\"Object containing arguments for the command.\"\n    )\n\n    def reply(self, *a, **kw) -&gt; Response:\n        \"\"\"Create a response message for the request.\n\n        This method is for reverse requests only.\"\"\"\n        ...\n</code></pre>"},{"location":"api-reference/#dap.base.Request.reply","title":"<code>reply(*a, **kw)</code>","text":"<p>Create a response message for the request.</p> <p>This method is for reverse requests only.</p> Source code in <code>src\\dap\\base.py</code> <pre><code>def reply(self, *a, **kw) -&gt; Response:\n    \"\"\"Create a response message for the request.\n\n    This method is for reverse requests only.\"\"\"\n    ...\n</code></pre>"},{"location":"api-reference/#dap.base.RequestArguments","title":"<code>RequestArguments</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base class of request arguments</p> Source code in <code>src\\dap\\base.py</code> <pre><code>class RequestArguments(BaseModel):\n    \"\"\"Base class of request arguments\"\"\"\n</code></pre>"},{"location":"api-reference/#dap.base.Requests","title":"<code>Requests</code>","text":"<p>               Bases: <code>StrEnum</code></p> <p>Enumeration of DAP requests.</p> Source code in <code>src\\dap\\base.py</code> <pre><code>class Requests(StrEnum):\n    \"\"\"Enumeration of DAP requests.\"\"\"\n\n    CANCEL = \"cancel\"\n    ATTACH = \"attach\"\n    BREAKPOINTLOCATIONS = \"breakpointLocations\"\n    COMPLETIONS = \"completions\"\n    CONFIGURATIONDONE = \"configurationDone\"\n    CONTINUE = \"continue\"\n    DATABREAKPOINTINFO = \"dataBreakpointInfo\"\n    DISASSEMBLE = \"disassemble\"\n    DISCONNECT = \"disconnect\"\n    EVALUATE = \"evaluate\"\n    EXCEPTIONINFO = \"exceptionInfo\"\n    GOTO = \"goto\"\n    GOTOTARGETS = \"gotoTargets\"\n    INITIALIZE = \"initialize\"\n    LAUNCH = \"launch\"\n    LOADEDSOURCES = \"loadedSources\"\n    MODULES = \"modules\"\n    NEXT = \"next\"\n    PAUSE = \"pause\"\n    READMEMORY = \"readMemory\"\n    RESTART = \"restart\"\n    RESTARTFRAME = \"restartFrame\"\n    REVERSECONTINUE = \"reverseContinue\"\n    SCOPES = \"scopes\"\n    SETBREAKPOINTS = \"setBreakpoints\"\n    SETDATABREAKPOINTS = \"setDataBreakpoints\"\n    SETEXCEPTIONBREAKPOINTS = \"setExceptionBreakpoints\"\n    SETEXPRESSION = \"setExpression\"\n    SETFUNCTIONBREAKPOINTS = \"setFunctionBreakpoints\"\n    SETINSTRUCTIONBREAKPOINTS = \"setInstructionBreakpoints\"\n    SETVARIABLE = \"setVariable\"\n    SOURCE = \"source\"\n    STACKTRACE = \"stackTrace\"\n    STEPBACK = \"stepBack\"\n    STEPIN = \"stepIn\"\n    STEPINTARGETS = \"stepInTargets\"\n    STEPOUT = \"stepOut\"\n    TERMINATE = \"terminate\"\n    TERMINATETHREADS = \"terminateThreads\"\n    THREADS = \"threads\"\n    VARIABLES = \"variables\"\n    WRITEMEMORY = \"writeMemory\"\n\n    # Reverse requests\n    RUNINTERMINAL = \"runInTerminal\"\n    STARTDEBUGGING = \"startDebugging\"\n</code></pre>"},{"location":"api-reference/#dap.base.ResponseBody","title":"<code>ResponseBody</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base class of response bodies</p> Source code in <code>src\\dap\\base.py</code> <pre><code>class ResponseBody(BaseModel):\n    \"\"\"Base class of response bodies\"\"\"\n\n    ...\n</code></pre>"},{"location":"api-reference/#connection","title":"Connection","text":""},{"location":"api-reference/#dap.connection.AsyncConnection","title":"<code>AsyncConnection</code>","text":"<p>Asyncio-based connection to a debug adapter server.</p> <p>This class is used to connect to a debug adapter server using asyncio. It provides methods to start, stop, read and write to the server.</p> Source code in <code>src\\dap\\connection.py</code> <pre><code>class AsyncConnection:\n    \"\"\"Asyncio-based connection to a debug adapter server.\n\n    This class is used to connect to a debug adapter server using asyncio.\n    It provides methods to start, stop, read and write to the server.\"\"\"\n\n    def __init__(self, host: str, port: int) -&gt; None:\n        self.host = host\n        self.port = port\n        self.reader: Optional[asyncio.StreamReader] = None\n        self.writer: Optional[asyncio.StreamWriter] = None\n        self.alive = False\n\n    async def start(self):\n        \"\"\"Start the connection to the server.\"\"\"\n\n        self.reader, self.writer = await asyncio.open_connection(self.host, self.port)\n        self.alive = True\n\n    async def stop(self):\n        \"\"\"Stop the connection to the server.\"\"\"\n\n        self.writer.close()\n        await self.writer.wait_closed()\n        self.alive = False\n\n    async def write(self, data: bytes):\n        \"\"\"Write data to the server\n\n        Args:\n            data (bytes): The data to write to the server.\n        \"\"\"\n\n        self.writer.write(data)\n        await self.writer.drain()\n\n    async def read(self) -&gt; bytes:\n        \"\"\"Read data from the server\n\n        Returns:\n            bytes: The data read from the server.\n        \"\"\"\n\n        return await self.reader.read(1024)\n</code></pre>"},{"location":"api-reference/#dap.connection.AsyncConnection.read","title":"<code>read()</code>  <code>async</code>","text":"<p>Read data from the server</p> <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>The data read from the server.</p> Source code in <code>src\\dap\\connection.py</code> <pre><code>async def read(self) -&gt; bytes:\n    \"\"\"Read data from the server\n\n    Returns:\n        bytes: The data read from the server.\n    \"\"\"\n\n    return await self.reader.read(1024)\n</code></pre>"},{"location":"api-reference/#dap.connection.AsyncConnection.start","title":"<code>start()</code>  <code>async</code>","text":"<p>Start the connection to the server.</p> Source code in <code>src\\dap\\connection.py</code> <pre><code>async def start(self):\n    \"\"\"Start the connection to the server.\"\"\"\n\n    self.reader, self.writer = await asyncio.open_connection(self.host, self.port)\n    self.alive = True\n</code></pre>"},{"location":"api-reference/#dap.connection.AsyncConnection.stop","title":"<code>stop()</code>  <code>async</code>","text":"<p>Stop the connection to the server.</p> Source code in <code>src\\dap\\connection.py</code> <pre><code>async def stop(self):\n    \"\"\"Stop the connection to the server.\"\"\"\n\n    self.writer.close()\n    await self.writer.wait_closed()\n    self.alive = False\n</code></pre>"},{"location":"api-reference/#dap.connection.AsyncConnection.write","title":"<code>write(data)</code>  <code>async</code>","text":"<p>Write data to the server</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>The data to write to the server.</p> required Source code in <code>src\\dap\\connection.py</code> <pre><code>async def write(self, data: bytes):\n    \"\"\"Write data to the server\n\n    Args:\n        data (bytes): The data to write to the server.\n    \"\"\"\n\n    self.writer.write(data)\n    await self.writer.drain()\n</code></pre>"},{"location":"api-reference/#dap.connection.Connection","title":"<code>Connection</code>","text":"<p>Connection to a debug adapter server.</p> <p>This class is used to connect to a debug adapter server using threads. It provides methods to start, stop, read and write to the server.</p> Source code in <code>src\\dap\\connection.py</code> <pre><code>class Connection:\n    \"\"\"Connection to a debug adapter server.\n\n    This class is used to connect to a debug adapter server using threads.\n    It provides methods to start, stop, read and write to the server.\"\"\"\n\n    def __init__(self, host=\"localhost\", port=6789):\n        self.alive = True\n        self.host = host\n        self.port = port\n\n        self.out_queue = queue.Queue()\n\n    def write(self, buf: bytes) -&gt; None:\n        \"\"\"Write data to the server\n\n        Args:\n            buf (bytes): The data to write to the server.\n        \"\"\"\n\n        self.sock.sendall(buf)\n\n    def read(self) -&gt; None:\n        \"\"\"Read data from the server\n\n        Returns:\n            bytes: The data read from the server.\n        \"\"\"\n\n        buf = bytearray()\n        while True:\n            try:\n                buf += self.out_queue.get(block=False)\n            except queue.Empty:\n                break\n\n        if self.t_out.is_alive() and not buf:\n            return None\n        return bytes(buf)\n\n    def start(self, *_) -&gt; None:\n        \"\"\"Start the connection to the server.\"\"\"\n\n        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.sock.connect((self.host, self.port))\n\n        self.t_out = Thread(target=self._process_output, daemon=True)\n        self.t_out.start()\n\n    def stop(self, *_) -&gt; None:\n        \"\"\"Stop the connection to the server.\"\"\"\n\n        self.alive = False\n        self.sock.close()\n\n    def _process_output(self) -&gt; None:\n        while self.alive:\n            try:\n                data = self.sock.recv(1024)\n            except ConnectionAbortedError:\n                break\n            except ConnectionResetError:\n                break\n\n            if not data:\n                break\n\n            self.out_queue.put(data)\n</code></pre>"},{"location":"api-reference/#dap.connection.Connection.read","title":"<code>read()</code>","text":"<p>Read data from the server</p> <p>Returns:</p> Name Type Description <code>bytes</code> <code>None</code> <p>The data read from the server.</p> Source code in <code>src\\dap\\connection.py</code> <pre><code>def read(self) -&gt; None:\n    \"\"\"Read data from the server\n\n    Returns:\n        bytes: The data read from the server.\n    \"\"\"\n\n    buf = bytearray()\n    while True:\n        try:\n            buf += self.out_queue.get(block=False)\n        except queue.Empty:\n            break\n\n    if self.t_out.is_alive() and not buf:\n        return None\n    return bytes(buf)\n</code></pre>"},{"location":"api-reference/#dap.connection.Connection.start","title":"<code>start(*_)</code>","text":"<p>Start the connection to the server.</p> Source code in <code>src\\dap\\connection.py</code> <pre><code>def start(self, *_) -&gt; None:\n    \"\"\"Start the connection to the server.\"\"\"\n\n    self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    self.sock.connect((self.host, self.port))\n\n    self.t_out = Thread(target=self._process_output, daemon=True)\n    self.t_out.start()\n</code></pre>"},{"location":"api-reference/#dap.connection.Connection.stop","title":"<code>stop(*_)</code>","text":"<p>Stop the connection to the server.</p> Source code in <code>src\\dap\\connection.py</code> <pre><code>def stop(self, *_) -&gt; None:\n    \"\"\"Stop the connection to the server.\"\"\"\n\n    self.alive = False\n    self.sock.close()\n</code></pre>"},{"location":"api-reference/#dap.connection.Connection.write","title":"<code>write(buf)</code>","text":"<p>Write data to the server</p> <p>Parameters:</p> Name Type Description Default <code>buf</code> <code>bytes</code> <p>The data to write to the server.</p> required Source code in <code>src\\dap\\connection.py</code> <pre><code>def write(self, buf: bytes) -&gt; None:\n    \"\"\"Write data to the server\n\n    Args:\n        buf (bytes): The data to write to the server.\n    \"\"\"\n\n    self.sock.sendall(buf)\n</code></pre>"},{"location":"api-reference/#threaded-socket-io-client","title":"Threaded Socket IO Client","text":"<p>Abstract Threaded server implementation of the DAP Client</p> <p>It is meant to be used as a base class for creating a server. It handles the connection and the client. Following methods need to be implemented by the child class: - handle_message</p> Source code in <code>src\\dap\\server.py</code> <pre><code>class ThreadedServer:\n    \"\"\"Abstract Threaded server implementation of the DAP Client\n\n    It is meant to be used as a base class for creating a server. It handles the connection and the client.\n    Following methods need to be implemented by the child class:\n    - handle_message\n    \"\"\"\n\n    def __init__(self, adapter_id: str, host=\"localhost\", port=6789) -&gt; None:\n        \"\"\"Initializes the server with the given adapter_id, host and port\n\n        Args:\n            adapter_id (str): The adapter id\n            host (str, optional): The host to connect to. Defaults to \"localhost\".\n            port (int, optional): The port to connect to. Defaults to 6789.\n        \"\"\"\n\n        self.connection = Connection(host, port)\n        self.connection.start()\n\n        self.client = Client(adapter_id)\n        self.running = False\n\n    def start(self):\n        \"\"\"Starts the server\"\"\"\n\n        self.running = True\n        threading.Thread(target=self._run_loop, daemon=True).start()\n\n    def stop(self):\n        \"\"\"Stops the server\"\"\"\n\n        self.running = False\n        self.client.terminate()\n        self.connection.stop()\n\n    def _run_loop(self):\n        while self.running and self.connection.alive and self.run_single():\n            ...\n\n    def run_single(self):\n        if s := self.client.send():\n            self.connection.write(s)\n\n        r = self.connection.read()\n        if not r:\n            return False\n\n        for result in self.client.receive(r):\n            self.handle_message(result)\n\n        return True\n\n    def handle_message(self, message):\n        \"\"\"Handles the message received from the client\n\n        To be implemented by child classes\n        Args:\n            message (Any): The message to handle\n        \"\"\"\n\n        print(type(message), flush=True)\n</code></pre>"},{"location":"api-reference/#dap.server.ThreadedServer.__init__","title":"<code>__init__(adapter_id, host='localhost', port=6789)</code>","text":"<p>Initializes the server with the given adapter_id, host and port</p> <p>Parameters:</p> Name Type Description Default <code>adapter_id</code> <code>str</code> <p>The adapter id</p> required <code>host</code> <code>str</code> <p>The host to connect to. Defaults to \"localhost\".</p> <code>'localhost'</code> <code>port</code> <code>int</code> <p>The port to connect to. Defaults to 6789.</p> <code>6789</code> Source code in <code>src\\dap\\server.py</code> <pre><code>def __init__(self, adapter_id: str, host=\"localhost\", port=6789) -&gt; None:\n    \"\"\"Initializes the server with the given adapter_id, host and port\n\n    Args:\n        adapter_id (str): The adapter id\n        host (str, optional): The host to connect to. Defaults to \"localhost\".\n        port (int, optional): The port to connect to. Defaults to 6789.\n    \"\"\"\n\n    self.connection = Connection(host, port)\n    self.connection.start()\n\n    self.client = Client(adapter_id)\n    self.running = False\n</code></pre>"},{"location":"api-reference/#dap.server.ThreadedServer.handle_message","title":"<code>handle_message(message)</code>","text":"<p>Handles the message received from the client</p> <p>To be implemented by child classes Args:     message (Any): The message to handle</p> Source code in <code>src\\dap\\server.py</code> <pre><code>def handle_message(self, message):\n    \"\"\"Handles the message received from the client\n\n    To be implemented by child classes\n    Args:\n        message (Any): The message to handle\n    \"\"\"\n\n    print(type(message), flush=True)\n</code></pre>"},{"location":"api-reference/#dap.server.ThreadedServer.start","title":"<code>start()</code>","text":"<p>Starts the server</p> Source code in <code>src\\dap\\server.py</code> <pre><code>def start(self):\n    \"\"\"Starts the server\"\"\"\n\n    self.running = True\n    threading.Thread(target=self._run_loop, daemon=True).start()\n</code></pre>"},{"location":"api-reference/#dap.server.ThreadedServer.stop","title":"<code>stop()</code>","text":"<p>Stops the server</p> Source code in <code>src\\dap\\server.py</code> <pre><code>def stop(self):\n    \"\"\"Stops the server\"\"\"\n\n    self.running = False\n    self.client.terminate()\n    self.connection.stop()\n</code></pre>"},{"location":"api-reference/#asyncio-client","title":"Asyncio Client","text":"<p>Abstract Asyncio-based DAP server.</p> <p>Handles communication between the client and the adapter. Child classes should implement the following methods:</p> <ul> <li>handle_message: Handle a message from the client or adapter.</li> </ul> <p>Example:</p> <pre><code>class MyServer(AsyncServer):\n    def handle_message(self, message):\n        print(message)\n</code></pre> Source code in <code>src\\dap\\asyncserver.py</code> <pre><code>class AsyncServer:\n    \"\"\"Abstract Asyncio-based DAP server.\n\n    Handles communication between the client and the adapter. Child classes should\n    implement the following methods:\n\n    - handle_message: Handle a message from the client or adapter.\n\n    Example:\n\n    ```python\n    class MyServer(AsyncServer):\n        def handle_message(self, message):\n            print(message)\n    ```\n    \"\"\"\n\n    def __init__(\n        self, adapter_id: str, host: str = \"localhost\", port: int = 6789\n    ) -&gt; None:\n        self.connection = AsyncConnection(host, port)\n        self.client = Client(adapter_id)\n        self.running = False\n        self.loop: Optional[asyncio.AbstractEventLoop] = None\n\n    async def start(self):\n        \"\"\"Start the server.\"\"\"\n\n        await self.connection.start()\n        self.running = True\n        self.loop = asyncio.get_running_loop()\n        await self._run_loop()\n\n    async def stop(self):\n        \"\"\"Stop the server.\"\"\"\n\n        self.running = False\n        self.client.terminate()\n        await self.connection.stop()\n\n    async def _run_loop(self):\n        while self.running and self.connection.alive:\n            await self.run_single()\n            await asyncio.sleep(0.1)\n\n    async def run_single(self):\n        s = self.client.send()\n        if s:\n            await self.connection.write(s)\n\n        r = await self.connection.read()\n        for event in self.client.receive(r):\n            self.handle_message(event)\n\n        return True\n\n    def handle_message(self, message):\n        \"\"\"Handle a message from the client or adapter.\n\n        To be implemented by subclasses.\n        \"\"\"\n\n        print(type(message), flush=True)\n</code></pre>"},{"location":"api-reference/#dap.asyncserver.AsyncServer.handle_message","title":"<code>handle_message(message)</code>","text":"<p>Handle a message from the client or adapter.</p> <p>To be implemented by subclasses.</p> Source code in <code>src\\dap\\asyncserver.py</code> <pre><code>def handle_message(self, message):\n    \"\"\"Handle a message from the client or adapter.\n\n    To be implemented by subclasses.\n    \"\"\"\n\n    print(type(message), flush=True)\n</code></pre>"},{"location":"api-reference/#dap.asyncserver.AsyncServer.start","title":"<code>start()</code>  <code>async</code>","text":"<p>Start the server.</p> Source code in <code>src\\dap\\asyncserver.py</code> <pre><code>async def start(self):\n    \"\"\"Start the server.\"\"\"\n\n    await self.connection.start()\n    self.running = True\n    self.loop = asyncio.get_running_loop()\n    await self._run_loop()\n</code></pre>"},{"location":"api-reference/#dap.asyncserver.AsyncServer.stop","title":"<code>stop()</code>  <code>async</code>","text":"<p>Stop the server.</p> Source code in <code>src\\dap\\asyncserver.py</code> <pre><code>async def stop(self):\n    \"\"\"Stop the server.\"\"\"\n\n    self.running = False\n    self.client.terminate()\n    await self.connection.stop()\n</code></pre>"}]}